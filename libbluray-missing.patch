diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDGraphicsConfiguration.java libbluray/src/libbluray/bdj/java-j2me/java/awt/BDGraphicsConfiguration.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDGraphicsConfiguration.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/java/awt/BDGraphicsConfiguration.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,63 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  Libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.awt.color.ColorSpace;
+import java.awt.image.BufferedImage;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
+import java.awt.image.DirectColorModel;
+import java.awt.image.VolatileImage;
+
+class BDGraphicsConfiguration extends GraphicsConfiguration {
+    private BDGraphicsDevice device;
+
+    BDGraphicsConfiguration(BDGraphicsDevice device) {
+        this.device = device;
+    }
+
+    public GraphicsDevice getDevice() {
+        return device;
+    }
+
+    public Rectangle getBounds() {
+        return device.getBounds();
+    }
+
+    int getCompatibleImageType() {
+        return BufferedImage.TYPE_INT_ARGB;
+    }
+
+    public synchronized ColorModel getColorModel() {
+        return new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),
+                                    32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000, true,
+                                    DataBuffer.TYPE_INT);
+    }
+
+    public BufferedImage createCompatibleImage(int width, int height) {
+        if (width <= 0 || height <= 0)
+            return null;
+        return BDImage.getBuffededImage(width, height, this);
+    }
+
+    public VolatileImage createCompatibleVolatileImage(int width, int height) {
+        return null;
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDGraphics.java libbluray/src/libbluray/bdj/java-j2me/java/awt/BDGraphics.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDGraphics.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/java/awt/BDGraphics.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,684 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.lang.reflect.Field;
+import java.text.AttributedCharacterIterator;
+import java.util.Arrays;
+import java.awt.image.AreaAveragingScaleFilter;
+import java.awt.image.BufferedImage;
+import java.awt.image.ImageConsumer;
+import java.awt.image.ImageObserver;
+
+import org.dvb.ui.DVBBufferedImage;
+
+import sun.awt.ConstrainableGraphics;
+
+import org.videolan.Logger;
+
+class BDGraphics extends Graphics2D implements ConstrainableGraphics {
+    private static final Color DEFAULT_COLOR = Color.BLACK;
+    private static final Font DEFAULT_FONT = new Font("Dialog", Font.PLAIN, 12);
+
+    private int width;
+    private int height;
+    private int[] backBuffer;
+    private Area dirty;
+    private GraphicsConfiguration gc;
+    private Color foreground;
+    private Color background;
+    private Font font;
+    private BDFontMetrics fontMetrics;
+    private AlphaComposite composite;
+
+    /** The current xor color. If null then we are in paint mode. */
+    private Color xorColor;
+
+    /** Translated X, Y offset from native offset. */
+    private int originX;
+    private int originY;
+
+    /** The actual clip rectangle that is intersection of user clip and constrained rectangle. */
+    private Rectangle actualClip;
+
+    /** The current user clip rectangle or null if no clip has been set. This is stored in the
+     native coordinate system and not the (possibly) translated Java coordinate system. */
+    private Rectangle clip;
+
+    /** The rectangle this graphics object has been constrained too. This is stored in the
+     native coordinate system and not the (possibly) translated Java coordinate system.
+     If it is null then this graphics has not been constrained. The constrained rectangle
+     is another layer of clipping independant of the user clip. */
+    private Rectangle constrainedRect;
+
+    BDGraphics(BDGraphics g) {
+        backBuffer = g.backBuffer;
+        dirty = g.dirty;
+        width = g.width;
+        height = g.height;
+        gc = g.gc;
+        foreground = g.foreground;
+        background = g.background;
+        composite = g.composite;
+        font = g.font;
+        fontMetrics = g.fontMetrics;
+        originX = g.originX;
+        originY = g.originY;
+        actualClip = g.clip;
+        clip = g.clip;
+        constrainedRect = g.constrainedRect;
+    }
+
+    BDGraphics(BDRootWindow window) {
+        width = window.getWidth();
+        height = window.getHeight();
+        backBuffer = window.getBdBackBuffer();
+        dirty = window.getDirtyArea();
+        gc = window.getGraphicsConfiguration();
+        foreground = window.getForeground();
+        background = window.getBackground();
+        font = window.getFont();
+        if (foreground == null)
+            foreground = DEFAULT_COLOR;
+        if (background == null)
+            background = DEFAULT_COLOR;
+        if (font == null)
+            font = DEFAULT_FONT;
+        fontMetrics = BDFontMetrics.getFontMetrics(font);
+        composite = AlphaComposite.SrcOver;
+        setupClip();
+    }
+
+    BDGraphics(BDImage image) {
+        width = image.getWidth();
+        height = image.getHeight();
+        backBuffer = image.getBdBackBuffer();
+        dirty = image.getDirtyArea();
+        gc = image.getGraphicsConfiguration();
+        Component component = image.getComponent();
+        if (component != null) {
+            foreground = component.getForeground();
+            background = component.getBackground();
+            font = component.getFont();
+        }
+        if (foreground == null)
+            foreground = DEFAULT_COLOR;
+        if (background == null)
+            background = DEFAULT_COLOR;
+        if (font == null)
+            font = DEFAULT_FONT;
+        fontMetrics = BDFontMetrics.getFontMetrics(font);
+        composite = AlphaComposite.SrcOver;
+        setupClip();
+    }
+
+    public Graphics create() {
+        return new BDGraphics(this);
+    }
+
+    public void translate(int x, int y) {
+        originX += x;
+        originY += y;
+    }
+
+    public void setFont(Font font) {
+        if (font != null && !font.equals(this.font)) {
+            this.font = font;
+            fontMetrics = BDFontMetrics.getFontMetrics(font);
+        }
+    }
+
+    public Font getFont() {
+        return font;
+    }
+
+    public FontMetrics getFontMetrics() {
+        return fontMetrics;
+    }
+
+    public FontMetrics getFontMetrics(Font font) {
+        return BDFontMetrics.getFontMetrics(font);
+    }
+
+    public void setColor(Color c) {
+        if ((c != null) && (c != foreground))
+            foreground = c;
+    }
+
+    public Color getColor() {
+        return foreground;
+    }
+
+    public Composite getComposite() {
+        return composite;
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration() {
+        return gc;
+    }
+
+    public void setComposite(Composite comp) {
+        if ((comp != null) && (comp != composite)) {
+            if (!(comp instanceof AlphaComposite))
+                throw new IllegalArgumentException("Only AlphaComposite is supported");
+            composite = (AlphaComposite) comp;
+        }
+    }
+
+    public void setPaintMode() {
+        xorColor = null;
+    }
+
+    public void setXORMode(Color color) {
+        xorColor = color;
+    }
+
+    /** Gets the current clipping area. */
+    public Rectangle getClipBounds() {
+        if (clip != null)
+            return new Rectangle (clip.x - originX, clip.y - originY, clip.width, clip.height);
+        return null;
+    }
+
+    public void constrain(int x, int y, int w, int h) {
+        Rectangle rect;
+        if (constrainedRect != null)
+            rect = constrainedRect;
+        else
+            rect = new Rectangle(0, 0, width, height);
+        constrainedRect = rect.intersection(new Rectangle(rect.x + x, rect.y + y, w, h));
+        originX = constrainedRect.x;
+        originY = constrainedRect.y;
+        setupClip();
+    }
+
+    /** Returns a Shape object representing the clip. */
+    public Shape getClip() {
+        return getClipBounds();
+    }
+
+    /** Crops the clipping rectangle. */
+    public void clipRect(int x, int y, int w, int h) {
+        Rectangle rect = new Rectangle(x + originX, y + originY, w, h);
+        if (clip != null)
+            clip = clip.intersection(rect);
+        else
+            clip = rect;
+        setupClip();
+    }
+
+    /** Sets the clipping rectangle. */
+    public void setClip(int x, int y, int w, int h) {
+        clip = new Rectangle (x + originX, y + originY, w, h);
+        setupClip();
+    }
+
+    /** Sets the clip to a Shape (only Rectangle allowed). */
+    public void setClip(Shape clip) {
+        if (clip == null) {
+            this.clip = null;
+            setupClip();
+        } else if (clip instanceof Rectangle) {
+            Rectangle rect = (Rectangle) clip;
+            setClip(rect.x, rect.y, rect.width, rect.height);
+        } else
+            throw new IllegalArgumentException("setClip(Shape) only supports Rectangle objects");
+    }
+
+    private void setupClip() {
+        Rectangle rect;
+        if (constrainedRect != null)
+            rect = constrainedRect;
+        else
+            rect = new Rectangle(0, 0, width, height);
+        if (clip != null)
+            actualClip = clip.intersection(rect);
+        else
+            actualClip = rect;
+    }
+
+    private int alphaBlend(int dest, int src) {
+        int As = src >>> 24;
+        if (As == 0)
+            return dest;
+        if (As == 255)
+            return src;
+        int Ad = (dest >>> 24);
+        if (Ad == 0)
+            return src;
+        int R, G, B;
+        R = ((src >>> 16) & 255) * As * 255;
+        G = ((src >>> 8) & 255) * As * 255;
+        B = (src & 255) * As * 255;
+        Ad = Ad * (255 - As);
+        As = As * 255 + Ad;
+        R = (R + ((dest >>> 16) & 255) * Ad) / As;
+        G = (G + ((dest >>> 8) & 255) * Ad) / As;
+        B = (B + (dest & 255) * Ad) / As;
+        R = Math.min(255, R);
+        G = Math.min(255, G);
+        B = Math.min(255, B);
+        Ad = As / 255;
+        Ad = Math.min(255, Ad);
+        return (Ad << 24) | (R << 16) | (G << 8) | B;
+    }
+
+    private void drawPointN(int x, int y, int rgb) {
+
+        dirty.add(x, y);
+
+        if (xorColor != null) {
+            backBuffer[y * width + x] ^= xorColor.getRGB() ^ rgb;
+            return;
+        }
+        int rule;
+        if (composite != null) {
+            rule = composite.getRule();
+            rgb = ((int)((rgb >>> 24) * composite.getAlpha()) << 24) | (rgb & 0x00FFFFFF);
+        } else {
+            rule = AlphaComposite.SRC_OVER;
+        }
+        switch (rule) {
+            case AlphaComposite.CLEAR:
+                backBuffer[y * width + x] = 0;
+                break;
+            case AlphaComposite.SRC:
+                backBuffer[y * width + x] = rgb;
+                break;
+            case AlphaComposite.SRC_OVER:
+                backBuffer[y * width + x] = alphaBlend(backBuffer[y * width + x], rgb);
+                break;
+        }
+    }
+
+    private void drawGlyph(int[] rgbArray, int x0, int y0, int w, int h) {
+        for (int y = 0; y < h; y++)
+            for (int x = 0; x < w; x++)
+                drawPoint(x + x0, y + y0, rgbArray[y * w + x]);
+    }
+
+    private void drawPoint(int x, int y, int rgb) {
+        x += originX;
+        y += originY;
+        if (actualClip.contains(x, y))
+            drawPointN(x, y, rgb);
+    }
+
+    public void clearRect(int x, int y, int w, int h) {
+        x += originX;
+        y += originY;
+        Rectangle rect = new Rectangle(x, y, w, h);
+        rect = actualClip.intersection(rect);
+        x = rect.x;
+        y = rect.y;
+        w = rect.width;
+        h = rect.height;
+        int rgb = background.getRGB();
+        for (int i = 0; i < h; i++)
+            Arrays.fill(backBuffer, (y + i) * width + x, (y + i) * width + x + w, rgb);
+
+        dirty.add(rect);
+    }
+
+    public void fillRect(int x, int y, int w, int h) {
+        x += originX;
+        y += originY;
+        Rectangle rect = new Rectangle(x, y, w, h);
+        rect = actualClip.intersection(rect);
+        x = rect.x;
+        y = rect.y;
+        w = rect.width;
+        h = rect.height;
+        int rgb = foreground.getRGB();
+        for (int Y = y; Y < (y + h); Y++)
+            for (int X = x; X < (x + w); X++)
+                drawPointN(X, Y, rgb);
+    }
+
+    public void drawRect(int x, int y, int w, int h) {
+        drawLineN(x, y, x + w, y);
+        drawLineN(x, y + h, x + w, y + h);
+        drawLineN(x, y, x, y + h);
+        drawLineN(x + w, y, x + w, y + h);
+    }
+
+    public void drawLineN(int x1, int y1, int x2, int y2) {
+        int rgb = foreground.getRGB();
+        int dy = y2 - y1;
+        int dx = x2 - x1;
+        int stepx, stepy;
+        int fraction;
+        if (dy < 0) {
+            dy = -dy;
+            stepy = -1;
+        } else {
+            stepy = 1;
+        }
+        if (dx < 0) {
+            dx = -dx;
+            stepx = -1;
+        } else {
+            stepx = 1;
+        }
+        dy <<= 1;
+        dx <<= 1;
+
+        drawPointN(x1, y1, rgb);
+
+        if (dx > dy) {
+            fraction = dy - (dx >> 1);
+            while (x1 != x2) {
+                if (fraction >= 0) {
+                    y1 += stepy;
+                    fraction -= dx;
+                }
+                x1 += stepx;
+                fraction += dy;
+                drawPointN(x1, y1, rgb);
+            }
+        } else {
+            fraction = dx - (dy >> 1);
+            while (y1 != y2) {
+                if (fraction >= 0) {
+                    x1 += stepx;
+                    fraction -= dy;
+                }
+                y1 += stepy;
+                fraction += dx;
+                drawPointN(x1, y1, rgb);
+            }
+        }
+    }
+
+    public void drawLine(int x1, int y1, int x2, int y2) {
+        drawLineN(x1, y1, x2, y2);
+    }
+
+    /**
+     * Copies an area of the canvas that this graphics context paints to.
+     * @param X the x-coordinate of the source.
+     * @param Y the y-coordinate of the source.
+     * @param W the width.
+     * @param H the height.
+     * @param dx the horizontal distance to copy the pixels.
+     * @param dy the vertical distance to copy the pixels.
+     */
+    public void copyArea(int X, int Y, int W, int H, int dx, int dy) {
+        X += originX;
+        Y += originY;
+        logger.unimplemented("copyArea");
+    }
+
+    /** Draws lines defined by an array of x points and y points */
+    public void drawPolyline(int xPoints[], int yPoints[], int nPoints) {
+        if (nPoints == 1) {
+            drawPointN(xPoints[0], yPoints[0], foreground.getRGB());
+        } else {
+            for (int i = 0; i < (nPoints - 1); i++)
+                drawLineN(xPoints[i], xPoints[i], xPoints[i + 1], xPoints[i + 1]);
+        }
+    }
+
+    /** Draws a polygon defined by an array of x points and y points */
+    public void drawPolygon(int xPoints[], int yPoints[], int nPoints) {
+        if (nPoints == 1) {
+            drawPointN(xPoints[0], yPoints[0], foreground.getRGB());
+        } else {
+            for (int i = 0; i < (nPoints - 1); i++)
+                drawLineN(xPoints[i], xPoints[i], xPoints[i + 1], xPoints[i + 1]);
+            if (nPoints > 2)
+                drawLineN(xPoints[0], xPoints[0], xPoints[nPoints - 1], xPoints[nPoints - 1]);
+        }
+    }
+
+    /** Fills a polygon with the current fill mask */
+    public void fillPolygon(int xPoints[], int yPoints[], int nPoints) {
+        logger.unimplemented("fillPolygon");
+    }
+
+    /** Draws an oval to fit in the given rectangle */
+    public void drawOval(int x, int y, int w, int h) {
+        logger.unimplemented("drawOval");
+    }
+
+    /** Fills an oval to fit in the given rectangle */
+    public void fillOval(int x, int y, int w, int h) {
+        logger.unimplemented("fillOval");
+    }
+
+    /**
+     * Draws an arc bounded by the given rectangle from startAngle to
+     * endAngle. 0 degrees is a vertical line straight up from the
+     * center of the rectangle. Positive start angle indicate clockwise
+     * rotations, negative angle are counter-clockwise.
+     */
+    public void drawArc(int x, int y, int w, int h, int startAngle, int endAngle) {
+        logger.unimplemented("drawArc");
+    }
+
+    /** fills an arc. arguments are the same as drawArc. */
+    public void fillArc(int x, int y, int w, int h, int startAngle, int endAngle) {
+        logger.unimplemented("fillArc");
+    }
+
+    /** Draws a rounded rectangle. */
+    public void drawRoundRect(int x, int y, int w, int h, int arcWidth, int arcHeight) {
+        logger.unimplemented("drawRoundRect");
+    }
+
+    /** Draws a filled rounded rectangle. */
+    public void fillRoundRect(int x, int y, int w, int h, int arcWidth, int arcHeight) {
+        logger.unimplemented("fillRoundRect");
+    }
+
+    protected native void drawStringN(long ftFace, String string, int x, int y, int rgb);
+
+    /** Draws the given string. */
+    public void drawString(String string, int x, int y) {
+        drawStringN(fontMetrics.ftFace, string, x, y, foreground.getRGB());
+    }
+
+    /** Draws the given character array. */
+    public void drawChars(char chars[], int offset, int length, int x, int y) {
+        drawStringN(fontMetrics.ftFace, new String(chars, offset, length), x, y, foreground.getRGB());
+    }
+
+    public void drawString(AttributedCharacterIterator arg0, int arg1, int arg2) {
+        logger.unimplemented("drawString");
+    }
+
+    /**
+     * Draws an image at x,y in nonblocking mode with a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
+        return drawImage(img, x, y, null, observer);
+    }
+
+    /**
+     * Draws an image at x,y in nonblocking mode with a solid background
+     * color and a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, Color bg,
+        ImageObserver observer) {
+        return drawImageN(img, x, y, -1, -1, 0, 0, -1, -1, bg, observer);
+    }
+
+    /**
+     * Draws an image scaled to x,y,w,h in nonblocking mode with a
+     * callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, int w, int h,
+        ImageObserver observer) {
+        return drawImage(img, x, y, w, h, null, observer);
+    }
+
+    /**
+     * Draws an image scaled to x,y,w,h in nonblocking mode with a
+     * solid background color and a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, int w, int h,
+        Color bg, ImageObserver observer) {
+        return drawImageN(img, x, y, w, h, 0, 0, -1, -1, bg, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle
+     * in nonblocking mode with a callback object.
+     */
+    public boolean drawImage(Image img,
+        int dx1, int dy1, int dx2, int dy2,
+        int sx1, int sy1, int sx2, int sy2,
+        ImageObserver observer) {
+        return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle in
+     * nonblocking mode with a solid background color and a callback object.
+     */
+    public boolean drawImage(Image img,
+        int dx1, int dy1, int dx2, int dy2,
+        int sx1, int sy1, int sx2, int sy2,
+        Color bg, ImageObserver observer) {
+        if ((dx1 >= dx2) || (dy1 >= dy2))
+            return false;
+        return drawImageN(img, dx1, dy1, dx2 - dx1, dy2 - dy1,
+                          sx1, sy1, sx2 - sx1, sy2 - sy1, bg, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle in
+     * nonblocking mode with a solid background color and a callback object.
+     */
+    protected boolean drawImageN(Image img,
+        int dx, int dy, int dw, int dh,
+        int sx, int sy, int sw, int sh,
+        Color bg, ImageObserver observer) {
+        if ((sx < 0) || (sy < 0) ||
+            (sw == 0) || (sh == 0) || (dw == 0) || (dh == 0))
+            return false;
+        BDImage bdImage;
+        if (img instanceof BDImage)
+            bdImage = (BDImage)img;
+        else if (img instanceof DVBBufferedImage)
+            bdImage = (BDImage)getBufferedImagePeer(
+                    (BufferedImage)(((DVBBufferedImage)img).getImage()));
+        else if (img instanceof BufferedImage)
+            bdImage = (BDImage)getBufferedImagePeer((BufferedImage)img);
+        else
+            return false;
+        if (bdImage instanceof BDImageConsumer) {
+            BDImageConsumer consumer = (BDImageConsumer)bdImage;
+            if (!consumer.isComplete(observer))
+                return false;
+        }
+
+        if(sx + sw > bdImage.width) {
+            int n = sx + sw - bdImage.width;
+            dw -= dw * n / sw;
+            sw -= n;
+        }
+
+        if(sy + sh > bdImage.height) {
+            int n = sy + sh - bdImage.height;
+            dh -= dh * n / sh;
+            sh -= n;
+        }
+
+        if ((sw > 0) && (sh > 0) &&
+            ((sx != 0) || (sy != 0) || (sw != bdImage.width) || (sh != bdImage.height))) {
+            BDImage subImage = new BDImage(null, sw, sh, null);
+            bdImage.getRGB(sx, sy, sw, sh, subImage.getBdBackBuffer(), 0, sw);
+            bdImage = subImage;
+        }
+        if ((dw > 0) && (dh > 0) &&
+            ((dw != bdImage.width) || (dh != bdImage.height))) {
+            BDImageConsumer scaledImage = new BDImageConsumer(null);
+            AreaAveragingScaleFilter scaleFilter =
+                new AreaAveragingScaleFilter(dw, dh);
+            scaleFilter = (AreaAveragingScaleFilter)scaleFilter.getFilterInstance(scaledImage);
+            scaleFilter.setDimensions(bdImage.width, bdImage.height);
+            scaleFilter.setPixels(0, 0, bdImage.width, bdImage.height,
+                                  bdImage.getColorModel(), bdImage.getBdBackBuffer(),
+                                  0, bdImage.width);
+            scaleFilter.imageComplete(ImageConsumer.STATICIMAGEDONE);
+            bdImage = scaledImage;
+        }
+        int[] rgbArray = bdImage.getBdBackBuffer();
+        int bgColor;
+        if (bg != null)
+            bgColor = bg.getRGB();
+        else
+            bgColor = 0;
+        // TODO: optimize this
+        for (int y = dy; y < (dy + bdImage.height); y++)
+            for (int x = dx; x < (dx + bdImage.width); x++) {
+                if (bg != null)
+                    drawPoint(x, y, bgColor);
+                drawPoint(x, y, rgbArray[(y - dy) * bdImage.width + (x - dx)]);
+            }
+        return true;
+    }
+
+    public Stroke getStroke() {
+        logger.unimplemented("getStroke");
+        throw new Error();
+    }
+
+    public void setStroke(Stroke stroke) {
+        logger.unimplemented("setStroke");
+    }
+
+    public void dispose() {
+    }
+
+    public String toString() {
+        return getClass().getName() + "[" + originX + "," + originY + "]";
+    }
+
+    private static Image getBufferedImagePeer(BufferedImage image) {
+        try {
+            return (Image)bufferedImagePeer.get(image);
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private static Field bufferedImagePeer;
+
+    static {
+        try {
+            Class c = Class.forName("java.awt.image.BufferedImage");
+            bufferedImagePeer = c.getDeclaredField("peer");
+            bufferedImagePeer.setAccessible(true);
+        } catch (ClassNotFoundException e) {
+            throw new AWTError("java.awt.image.BufferedImage not found");
+        } catch (SecurityException e) {
+            throw new AWTError("java.awt.image.BufferedImage.peer not accessible");
+        } catch (NoSuchFieldException e) {
+            throw new AWTError("java.awt.image.BufferedImage.peer not found");
+        }
+    }
+
+    private static final Logger logger = Logger.getLogger(BDGraphics.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDImage.java libbluray/src/libbluray/bdj/java-j2me/java/awt/BDImage.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDImage.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/java/awt/BDImage.java	2013-07-26 18:40:43.502463047 +0200
@@ -0,0 +1,28 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import sun.awt.image.BufferedImagePeer;
+
+public class BDImage extends BDImageBase implements BufferedImagePeer {
+    BDImage(Component component, int width, int height, GraphicsConfiguration gc) {
+        super(component, width, height, gc);
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDToolkit.java libbluray/src/libbluray/bdj/java-j2me/java/awt/BDToolkit.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/java/awt/BDToolkit.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/java/awt/BDToolkit.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,243 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.awt.image.ColorModel;
+import java.awt.image.ImageObserver;
+import java.awt.image.ImageProducer;
+import java.io.File;
+import java.net.URL;
+import java.util.Collections;
+import java.util.Hashtable;
+import java.util.WeakHashMap;
+import java.util.Map;
+import java.util.Iterator;
+
+import sun.awt.NullGraphics;
+import sun.awt.image.ByteArrayImageSource;
+import sun.awt.image.FileImageSource;
+import sun.awt.image.URLImageSource;
+
+import org.videolan.BDJXletContext;
+import org.videolan.Logger;
+
+public class BDToolkit extends Toolkit {
+    private EventQueue eventQueue = new EventQueue();
+    private BDGraphicsEnvironment localEnv = new BDGraphicsEnvironment();
+    private BDGraphicsConfiguration defaultGC = (BDGraphicsConfiguration)localEnv.getDefaultScreenDevice().getDefaultConfiguration();
+    private static Hashtable cachedImages = new Hashtable();
+    private static final Logger logger = Logger.getLogger(BDToolkit.class.getName());
+
+    public BDToolkit () {}
+
+    public static void setFocusedWindow(Window window) {
+        /* nothing to do */
+    }
+
+    public static void shutdown() {
+        Toolkit toolkit = getDefaultToolkit();
+        if (toolkit instanceof BDToolkit) {
+            ((BDToolkit)toolkit).dispose();
+        }
+    }
+
+    public void dispose() {
+        if (eventQueue != null) {
+            BDJHelper.stopEventQueue(eventQueue);
+            eventQueue = null;
+        }
+        cachedImages = null;
+    }
+
+    public Dimension getScreenSize() {
+        Rectangle dims = defaultGC.getBounds();
+        return new Dimension(dims.width, dims.height);
+    }
+
+    Graphics getGraphics(Window window) {
+        if (!(window instanceof BDRootWindow))
+            return new NullGraphics(window);
+        return new BDWindowGraphics((BDRootWindow)window);
+    }
+
+    GraphicsEnvironment getLocalGraphicsEnvironment() {
+        return localEnv;
+    }
+
+    public int getScreenResolution() {
+        return 72;
+    }
+
+    public ColorModel getColorModel() {
+        return defaultGC.getColorModel();
+    }
+
+    public String[] getFontList() {
+        return BDFontMetrics.getFontList();
+    }
+
+    public FontMetrics getFontMetrics(Font font) {
+        return BDFontMetrics.getFontMetrics(font);
+    }
+
+    public void sync() {
+        Window window = ((BDGraphicsDevice)localEnv.getDefaultScreenDevice()).getWindow();
+        if (window instanceof BDRootWindow)
+            ((BDRootWindow)window).sync();
+    }
+
+    static void clearCache(BDImage image) {
+        synchronized (cachedImages) {
+            Iterator i = cachedImages.entrySet().iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry) i.next();
+                if (entry.getValue() == image) {
+                    i.remove();
+                    return;
+                }
+            }
+        }
+    }
+
+    public Image getImage(String filename) {
+        if (cachedImages.containsKey(filename))
+            return (Image)cachedImages.get(filename);
+        Image newImage = createImage(filename);
+        if (newImage != null)
+            cachedImages.put(filename, newImage);
+        return newImage;
+    }
+
+    public Image getImage(URL url) {
+        if (cachedImages.containsKey(url))
+            return (Image)cachedImages.get(url);
+        Image newImage = createImage(url);
+        if (newImage != null)
+            cachedImages.put(url, newImage);
+        return newImage;
+    }
+
+    public Image createImage(String filename) {
+        if (!new File(filename).exists()) {
+            BDJXletContext ctx = BDJXletContext.getCurrentContext();
+            if (ctx != null) {
+                ClassLoader cldr = (ClassLoader)ctx.getClassLoader();
+                URL url = cldr.getResource(filename);
+                if (url != null) {
+                    logger.warning("" + filename + " translated to " + url);
+                    return createImage(url);
+                } else {
+                    logger.error("ClassLoader failed to translate " + filename);
+                }
+            } else {
+                logger.error("createImage(" + filename + "): no XletContext available!\n" + logger.dumpStack());
+            }
+        }
+
+        ImageProducer ip = new FileImageSource(filename);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(URL url) {
+        ImageProducer ip = new URLImageSource(url);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(byte[] imagedata,
+        int imageoffset,
+        int imagelength) {
+        ImageProducer ip = new ByteArrayImageSource(imagedata, imageoffset, imagelength);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(ImageProducer producer) {
+        return new BDImageConsumer(producer);
+    }
+
+    public Image createImage(Component component, int width, int height) {
+        return new BDImage(component, width, height, defaultGC);
+    }
+
+    public boolean prepareImage(Image image, int width, int height, ImageObserver observer) {
+        if (!(image instanceof BDImageConsumer))
+            return true;
+        BDImageConsumer img = (BDImageConsumer)image;
+        return img.prepareImage(observer);
+    }
+
+    public int checkImage(Image image, int width, int height,
+        ImageObserver observer) {
+        if (!(image instanceof BDImageConsumer)) {
+            return ImageObserver.ALLBITS;
+        }
+        BDImageConsumer img = (BDImageConsumer)image;
+        return img.checkImage(observer);
+    }
+
+    public void beep() { }
+
+    // mapping of Components to AppContexts, WeakHashMap<Component,AppContext>
+    private static final Map contextMap =
+        Collections.synchronizedMap(new WeakHashMap());
+
+    public static void addComponent(Component component) {
+
+        BDJXletContext context = BDJXletContext.getCurrentContext();
+        if (context == null) {
+            logger.warning("addComponent() outside of app context");
+            return;
+        }
+        contextMap.put(component, context);
+    }
+
+    public static EventQueue getEventQueue(Component component) {
+        if (component != null) {
+            do {
+                BDJXletContext ctx = (BDJXletContext)contextMap.get(component);
+                if (ctx != null) {
+                    EventQueue eq = ctx.getEventQueue();
+                    if (eq == null) {
+                        logger.warning("getEventQueue() failed: no context event queue");
+                    }
+                    return eq;
+                }
+
+                component = component.getParent();
+            } while (component != null);
+
+            logger.warning("getEventQueue() failed: no context");
+        }
+        return null;
+    }
+
+    protected EventQueue getSystemEventQueueImpl() {
+        BDJXletContext ctx = BDJXletContext.getCurrentContext();
+        if (ctx != null) {
+            EventQueue eq = ctx.getEventQueue();
+            if (eq != null) {
+                return eq;
+            }
+        }
+        return eventQueue;
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/io/ixc/IxcRegistry.java libbluray/src/libbluray/bdj/java-j2me/org/dvb/io/ixc/IxcRegistry.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/io/ixc/IxcRegistry.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/org/dvb/io/ixc/IxcRegistry.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,124 @@
+/*
+ * This file is part of libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.io.ixc;
+
+import java.rmi.AccessException;
+import java.rmi.RemoteException;
+import java.rmi.NotBoundException;
+import java.rmi.AlreadyBoundException;
+import java.rmi.Remote;
+
+import javax.microedition.xlet.ixc.StubException;
+import javax.tv.xlet.XletContext;
+
+import org.dvb.application.AppID;
+import org.dvb.application.AppProxy;
+import org.dvb.application.AppsDatabase;
+import org.videolan.BDJXletContext;
+
+public class IxcRegistry {
+    private static javax.microedition.xlet.ixc.IxcRegistry getIxcRegistry(XletContext xc) {
+        if (!(xc instanceof BDJXletContext))
+            throw new IllegalArgumentException();
+        javax.microedition.xlet.ixc.IxcRegistry registry;
+        registry = javax.microedition.xlet.ixc.IxcRegistry.getRegistry((BDJXletContext)xc);
+        if (registry == null)
+            throw new IllegalArgumentException();
+        return registry;
+    }
+
+    public static Remote lookup(XletContext xc, String path) throws NotBoundException, RemoteException {
+        int orgid, appid;
+        int s1, s2;
+        if (path.charAt(0) != '/')
+            throw new IllegalArgumentException();
+        s1 = path.indexOf('/', 1);
+        if (s1 <= 1)
+            throw new IllegalArgumentException();
+        try {
+            orgid = Integer.parseInt(path.substring(1, s1), 16);
+        } catch (Exception e) {
+            throw new IllegalArgumentException();
+        }
+        s1++;
+        s2 = path.indexOf('/', s1);
+        if (s2 <= s1)
+            throw new IllegalArgumentException();
+        try {
+            appid = Integer.parseInt(path.substring(s1, s2), 16);
+        } catch (Exception e) {
+            throw new IllegalArgumentException();
+        }
+        String key = "/" + Integer.toHexString(orgid) +
+                     "/" + Integer.toHexString(appid) +
+                     "/" + path.substring(s2 + 1, path.length());
+        return getIxcRegistry(xc).lookup(key);
+    }
+
+    public static void bind(XletContext xc, String name, Remote obj) throws AlreadyBoundException {
+        if ((xc == null) || (name == null) || (obj == null))
+            throw new NullPointerException();
+        String orgid = (String)xc.getXletProperty("dvb.org.id");
+        String appid = (String)xc.getXletProperty("dvb.app.id");
+        AppID id = new AppID(Integer.parseInt(orgid, 16), Integer.parseInt(appid, 16));
+        if (AppsDatabase.getAppsDatabase().getAppProxy(id).getState() == AppProxy.DESTROYED)
+            return;
+        String key = "/" + orgid + "/" + appid + "/" + name;
+        try {
+            getIxcRegistry(xc).bind(key, obj);
+        } catch (StubException e) {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    public static void unbind(XletContext xc, String name) throws NotBoundException {
+        if ((xc == null) || (name == null))
+            throw new NullPointerException();
+        String key = "/" + (String)xc.getXletProperty("dvb.org.id") +
+                     "/" + (String)xc.getXletProperty("dvb.app.id") +
+                     "/" + name;
+        try {
+            getIxcRegistry(xc).unbind(key);
+        } catch (AccessException e) {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    public static void rebind(XletContext xc, String name, Remote obj) {
+        if ((xc == null) || (name == null) || (obj == null))
+            throw new NullPointerException();
+        String orgid = (String)xc.getXletProperty("dvb.org.id");
+        String appid = (String)xc.getXletProperty("dvb.app.id");
+        AppID id = new AppID(Integer.parseInt(orgid, 16), Integer.parseInt(appid, 16));
+        if (AppsDatabase.getAppsDatabase().getAppProxy(id).getState() == AppProxy.DESTROYED)
+            return;
+        String key = "/" + orgid + "/" + appid + "/" + name;
+        try {
+            getIxcRegistry(xc).rebind(key, obj);
+        } catch (StubException e) {
+            throw new IllegalArgumentException();
+        } catch (AccessException e) {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    public static String[] list(XletContext xc) {
+        return getIxcRegistry(xc).list();
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/ui/DVBGraphicsImpl.java libbluray/src/libbluray/bdj/java-j2me/org/dvb/ui/DVBGraphicsImpl.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/ui/DVBGraphicsImpl.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/org/dvb/ui/DVBGraphicsImpl.java	2013-07-26 18:40:43.502463047 +0200
@@ -0,0 +1,359 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.ui;
+
+import java.awt.AlphaComposite;
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.Stroke;
+import java.awt.image.ImageObserver;
+import java.text.AttributedCharacterIterator;
+
+public class DVBGraphicsImpl extends DVBGraphics {
+    protected DVBGraphicsImpl(Graphics2D gfx)
+    {
+        super(gfx);
+    }
+
+    /*
+     * Graphics methods
+     */
+    public void clearRect(int x, int y, int width, int height)
+    {
+        gfx.clearRect(x, y, width, height);
+    }
+
+    public void clipRect(int x, int y, int width, int height)
+    {
+        gfx.clipRect(x, y, width, height);
+    }
+
+    public void copyArea(int x, int y, int width, int height, int dx, int dy)
+    {
+        gfx.copyArea(x, y, width, height, dx, dy);
+    }
+
+    public Graphics create()
+    {
+        return gfx.create();
+    }
+
+    public Graphics create(int x, int y, int width, int height)
+    {
+        return gfx.create(x, y, width, height);
+    }
+
+    public void dispose()
+    {
+        gfx.dispose();
+    }
+
+    public void draw3DRect(int x, int y, int width, int height, boolean raised)
+    {
+        gfx.draw3DRect(x, y, width, height, raised);
+    }
+
+    public void drawArc(int x, int y, int width, int height, int startAngle,
+            int arcAngle)
+    {
+        gfx.drawArc(x, y, width, height, startAngle, arcAngle);
+    }
+
+    public void drawBytes(byte[] data, int offset, int length, int x, int y)
+    {
+        gfx.drawBytes(data, offset, length, x, y);
+    }
+
+    public void drawChars(char[] data, int offset, int length, int x, int y)
+    {
+        gfx.drawChars(data, offset, length, x, y);
+    }
+
+    public boolean drawImage(Image img, int x, int y, Color bgcolor,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, int width, int height,
+            Color bgcolor, ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, width, height, bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, int width, int height,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, width, height, observer);
+    }
+
+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,
+            int sx1, int sy1, int sx2, int sy2, Color bgcolor,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
+                             bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,
+            int sx1, int sy1, int sx2, int sy2, ImageObserver observer)
+    {
+        return gfx.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
+                             observer);
+    }
+
+    public void drawLine(int x1, int y1, int x2, int y2)
+    {
+        gfx.drawLine(x1, y1, x2, y2);
+    }
+
+    public void drawOval(int x, int y, int width, int height)
+    {
+        gfx.drawOval(x, y, width, height);
+    }
+
+    public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.drawPolygon(xPoints, yPoints, nPoints);
+    }
+
+    public void drawPolygon(Polygon p)
+    {
+        gfx.drawPolygon(p);
+    }
+
+    public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.drawPolyline(xPoints, yPoints, nPoints);
+    }
+
+    public void drawRect(int x, int y, int width, int height)
+    {
+        gfx.drawRect(x, y, width, height);
+    }
+
+    public void drawRoundRect(int x, int y, int width, int height,
+            int arcWidth, int arcHeight)
+    {
+        gfx.drawRoundRect(x, y, width, height, arcWidth, arcHeight);
+    }
+
+    public void drawString(AttributedCharacterIterator iterator, int x, int y)
+    {
+        gfx.drawString(iterator, x, y);
+    }
+
+    public void drawString(String str, int x, int y)
+    {
+        gfx.drawString(str, x, y);
+    }
+
+    public void fill3DRect(int x, int y, int width, int height, boolean raised)
+    {
+        gfx.fill3DRect(x, y, width, height, raised);
+    }
+
+    public void fillArc(int x, int y, int width, int height, int startAngle,
+            int arcAngle)
+    {
+        gfx.fillArc(x, y, width, height, startAngle, arcAngle);
+    }
+
+    public void fillOval(int x, int y, int width, int height)
+    {
+        gfx.fillOval(x, y, width, height);
+    }
+
+    public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.fillPolygon(xPoints, yPoints, nPoints);
+    }
+
+    public void fillPolygon(Polygon p)
+    {
+        gfx.fillPolygon(p);
+    }
+
+    public void fillRect(int x, int y, int width, int height)
+    {
+        gfx.fillRect(x, y, width, height);
+    }
+
+    public void fillRoundRect(int x, int y, int width, int height,
+            int arcWidth, int arcHeight)
+    {
+        gfx.fillRoundRect(x, y, width, height, arcWidth, arcHeight);
+    }
+
+    public void finalize()
+    {
+        gfx.finalize();
+    }
+
+    public Shape getClip()
+    {
+        return gfx.getClip();
+    }
+
+    public Rectangle getClipBounds()
+    {
+        return gfx.getClipBounds();
+    }
+
+    public Rectangle getClipBounds(Rectangle r)
+    {
+        return gfx.getClipBounds(r);
+    }
+
+    public Color getColor()
+    {
+        return gfx.getColor();
+    }
+
+    public Font getFont()
+    {
+        return gfx.getFont();
+    }
+
+    public FontMetrics getFontMetrics()
+    {
+        return gfx.getFontMetrics();
+    }
+
+    public FontMetrics getFontMetrics(Font f)
+    {
+        return gfx.getFontMetrics(f);
+    }
+
+    public boolean hitClip(int x, int y, int width, int height)
+    {
+        return gfx.hitClip(x, y, width, height);
+    }
+
+    public void setClip(int x, int y, int width, int height)
+    {
+        gfx.setClip(x, y, width, height);
+    }
+
+    public void setClip(Shape clip)
+    {
+        gfx.setClip(clip);
+    }
+
+    public void setColor(Color c)
+    {
+        gfx.setColor(c);
+    }
+
+    public void setFont(Font font)
+    {
+        gfx.setFont(font);
+    }
+
+    public void setPaintMode()
+    {
+        gfx.setPaintMode();
+    }
+
+    public void setXORMode(Color c1)
+    {
+        gfx.setXORMode(c1);
+    }
+
+    public void translate(int x, int y)
+    {
+        gfx.translate(x, y);
+    }
+
+    /*
+     * DVBGraphics methods
+     */
+    public int[] getAvailableCompositeRules()
+    {
+        int[] rules = {
+            DVBAlphaComposite.CLEAR,
+            DVBAlphaComposite.SRC,
+            DVBAlphaComposite.SRC_OVER };
+
+        return rules;
+    }
+
+    public DVBAlphaComposite getDVBComposite()
+    {
+        Composite comp = gfx.getComposite();
+        if (!(comp instanceof AlphaComposite))
+            return null;
+        return DVBAlphaComposite.getInstance(
+                        ((AlphaComposite)comp).getRule(),
+                        ((AlphaComposite)comp).getAlpha());
+    }
+
+    public void setDVBComposite(DVBAlphaComposite comp)
+            throws UnsupportedDrawingOperationException
+    {
+        if ((comp.getRule() < DVBAlphaComposite.CLEAR) ||
+            (comp.getRule() > DVBAlphaComposite.SRC_OVER))
+            throw new UnsupportedDrawingOperationException("Unsupported composition rule");
+
+        gfx.setComposite(AlphaComposite.getInstance(comp.getRule(), comp.getAlpha()));
+    }
+
+    /*
+     * Graphics2D methods
+     */
+    public Composite getComposite()
+    {
+        return gfx.getComposite();
+    }
+
+    public Stroke getStroke()
+    {
+        return gfx.getStroke();
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration()
+    {
+        return gfx.getDeviceConfiguration();
+    }
+
+    public void setComposite(Composite comp)
+    {
+        gfx.setComposite(comp);
+    }
+
+    public void setStroke(Stroke s)
+    {
+        gfx.setStroke(s);
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/ui/FontFactory.java libbluray/src/libbluray/bdj/java-j2me/org/dvb/ui/FontFactory.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/org/dvb/ui/FontFactory.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/org/dvb/ui/FontFactory.java	2013-07-26 18:40:43.502463047 +0200
@@ -0,0 +1,111 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  William Hahne
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.ui;
+
+import java.awt.Font;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import java.net.URL;
+import java.net.URLConnection;
+
+import org.videolan.BDJUtil;
+import org.videolan.FontIndex;
+import org.videolan.FontIndexData;
+import org.videolan.Logger;
+
+import sun.net.www.ParseUtil;
+
+public class FontFactory {
+    public static void loadDiscFonts() {
+        unloadDiscFonts();
+
+        fonts = FontIndex.parseIndex(BDJUtil.discRootToFilesystem("/BDMV/AUXDATA/dvb.fontindex"));
+
+        if (fonts != null) {
+            logger.trace("Disc fonts:");
+            for (int i = 0; i < fonts.length; i++)
+                System.err.println("    "+(i+1)+": " + fonts[i].toString());
+        } else {
+            logger.trace("No fonts loaded from disc");
+        }
+    }
+
+    public static void unloadDiscFonts() {
+        if (fonts != null) {
+            fonts = null;
+        }
+    }
+
+    public FontFactory() throws FontFormatException, IOException {
+        if (fonts == null)
+            throw new IOException("There is no font data");
+    }
+
+    public FontFactory(URL u) throws IOException, FontFormatException {
+        String path = u.getPath().replace('/', File.separatorChar);
+        path = ParseUtil.decode(path);
+        if (u.getProtocol().equals("file")) {
+            path = path.replace('/', File.separatorChar);
+            file = new File(path);
+        } else {
+            int index = path.lastIndexOf('/');
+            if (index >= 0)
+                path = path.substring(index + 1);
+            path = System.getProperty("bluray.vfs.root") + File.separator + path;
+
+            URLConnection uc = u.openConnection();
+            InputStream is = uc.getInputStream();
+            FileOutputStream os = null;
+            try {
+                os = new FileOutputStream(path);
+                byte[] buf = new byte[1024];
+                int len;
+                while ((len = is.read(buf)) > 0)
+                    os.write(buf, 0, len);
+                file = new File(path);
+            } finally {
+                try {
+                    is.close();
+                    os.close();
+                } catch (Throwable e) {
+                    file = null;
+                }
+            }
+        }
+        if (file == null)
+            throw new IOException();
+    }
+
+    public Font createFont(String name, int style, int size)
+            throws FontNotAvailableException, FontFormatException, IOException {
+        logger.info("Creating font: " + name + " " + style + " " + size);
+
+        return new Font(name, style, size);
+    }
+
+    private File file = null;
+    private static FontIndexData[] fonts = null;
+
+    private static final Logger logger = Logger.getLogger(FontFactory.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2me.orig/org/videolan/PortingHelper.java libbluray/src/libbluray/bdj/java-j2me/org/videolan/PortingHelper.java
--- libbluray/src/libbluray/bdj/java-j2me.orig/org/videolan/PortingHelper.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2me/org/videolan/PortingHelper.java	2013-07-26 18:40:43.502463047 +0200
@@ -0,0 +1,29 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2013  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.videolan;
+
+public class PortingHelper {
+
+    public static void stopThread(Thread t) {
+    }
+
+    public static void stopThreadGroup(ThreadGroup t) {
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDGraphicsConfiguration.java libbluray/src/libbluray/bdj/java-j2se/java/awt/BDGraphicsConfiguration.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDGraphicsConfiguration.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/BDGraphicsConfiguration.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,106 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  Libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.awt.color.ColorSpace;
+import java.awt.image.BufferedImage;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
+import java.awt.image.DirectColorModel;
+import java.awt.image.VolatileImage;
+
+class BDGraphicsConfiguration extends GraphicsConfiguration {
+    private BDGraphicsDevice device;
+
+    BDGraphicsConfiguration(BDGraphicsDevice device) {
+        this.device = device;
+    }
+
+    public GraphicsDevice getDevice() {
+        return device;
+    }
+
+    public Rectangle getBounds() {
+        return device.getBounds();
+    }
+
+    int getCompatibleImageType() {
+        return BufferedImage.TYPE_INT_ARGB;
+    }
+
+    public java.awt.geom.AffineTransform getNormalizingTransform() {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "getNormalizingTransform");
+        return null;
+    }
+    public java.awt.geom.AffineTransform getDefaultTransform() {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "getDefaultTransform");
+        return null;
+    }
+    public java.awt.image.ColorModel getColorModel(int transparency) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "getColorModel");
+        return null;
+    }
+
+    public synchronized ColorModel getColorModel() {
+        return new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),
+                                    32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000, true,
+                                    DataBuffer.TYPE_INT);
+    }
+
+    public BufferedImage createCompatibleImage(int width, int height, int trans) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "createCompatibleImage");
+        return null;
+    }
+
+    public BufferedImage createCompatibleImage(int width, int height) {
+        if (width <= 0 || height <= 0)
+            return null;
+        return BDImage.getBuffededImage(width, height, this);
+    }
+
+    public VolatileImage createCompatibleVolatileImage(int width, int height) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "createCompatibleVolatileImage");
+        return null;
+    }
+
+    public VolatileImage createCompatibleVolatileImage(int width, int height, int trans) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "createCompatibleVolatileImage");
+        return null;
+    }
+
+    public VolatileImage createCompatibleVolatileImage(int width, int height, ImageCapabilities caps) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "createCompatibleVolatileImage");
+        return null;
+    }
+
+    public VolatileImage createCompatibleVolatileImage(int width, int height, ImageCapabilities caps, int trans) {
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "createCompatibleVolatileImage");
+        return null;
+    }
+
+    public BufferCapabilities getBufferCapabilities(){
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "getBufferCapabilities");
+        return super.getBufferCapabilities();
+    }
+    public ImageCapabilities getImageCapabilities(){
+        org.videolan.Logger.unimplemented("BDGraphicsConfiguration", "getImageCapabilities");
+        return super.getImageCapabilities();
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDGraphics.java libbluray/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDGraphics.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/BDGraphics.java	2013-07-26 19:56:40.242271819 +0200
@@ -0,0 +1,768 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.lang.reflect.Field;
+import java.text.AttributedCharacterIterator;
+import java.util.Arrays;
+import java.awt.image.AreaAveragingScaleFilter;
+import java.awt.image.BufferedImage;
+import java.awt.image.ImageConsumer;
+import java.awt.image.ImageObserver;
+import java.awt.font.*;
+import java.awt.image.renderable.RenderableImage;
+import java.awt.image.RenderedImage;
+import java.awt.geom.AffineTransform;
+
+import org.dvb.ui.DVBBufferedImage;
+
+import sun.awt.ConstrainableGraphics;
+
+import org.videolan.Logger;
+
+class BDGraphics extends Graphics2D implements ConstrainableGraphics {
+    private static final Color DEFAULT_COLOR = Color.BLACK;
+    private static final Font DEFAULT_FONT = new Font("Dialog", Font.PLAIN, 12);
+
+    private int width;
+    private int height;
+    private int[] backBuffer;
+    private Area dirty;
+    private GraphicsConfiguration gc;
+    private Color foreground;
+    private Color background;
+    private Paint paint;
+    private Font font;
+    private BDFontMetrics fontMetrics;
+    private AlphaComposite composite;
+
+    /** The current xor color. If null then we are in paint mode. */
+    private Color xorColor;
+
+    /** Translated X, Y offset from native offset. */
+    private int originX;
+    private int originY;
+
+    /** The actual clip rectangle that is intersection of user clip and constrained rectangle. */
+    private Rectangle actualClip;
+
+    /** The current user clip rectangle or null if no clip has been set. This is stored in the
+     native coordinate system and not the (possibly) translated Java coordinate system. */
+    private Rectangle clip;
+
+    /** The rectangle this graphics object has been constrained too. This is stored in the
+     native coordinate system and not the (possibly) translated Java coordinate system.
+     If it is null then this graphics has not been constrained. The constrained rectangle
+     is another layer of clipping independant of the user clip. */
+    private Rectangle constrainedRect;
+
+    BDGraphics(BDGraphics g) {
+        backBuffer = g.backBuffer;
+        dirty = g.dirty;
+        width = g.width;
+        height = g.height;
+        gc = g.gc;
+        foreground = g.foreground;
+        background = g.background;
+        composite = g.composite;
+        font = g.font;
+        fontMetrics = g.fontMetrics;
+        originX = g.originX;
+        originY = g.originY;
+        actualClip = g.clip;
+        clip = g.clip;
+        constrainedRect = g.constrainedRect;
+        if (clip == null)
+            setupClip();
+    }
+
+    BDGraphics(BDRootWindow window) {
+        width = window.getWidth();
+        height = window.getHeight();
+        backBuffer = window.getBdBackBuffer();
+        dirty = window.getDirtyArea();
+        gc = window.getGraphicsConfiguration();
+        foreground = window.getForeground();
+        background = window.getBackground();
+        font = window.getFont();
+        if (foreground == null)
+            foreground = DEFAULT_COLOR;
+        if (background == null)
+            background = DEFAULT_COLOR;
+        if (font == null)
+            font = DEFAULT_FONT;
+        fontMetrics = BDFontMetrics.getFontMetrics(font);
+        composite = AlphaComposite.SrcOver;
+        setupClip();
+    }
+
+    public Color getBackground() {
+        return background;
+    }
+    public void setBackground(Color c) {
+        background = c;
+    }
+
+    BDGraphics(BDImage image) {
+        width = image.getWidth();
+        height = image.getHeight();
+        backBuffer = image.getBdBackBuffer();
+        dirty = image.getDirtyArea();
+
+        gc = image.getGraphicsConfiguration();
+        Component component = image.getComponent();
+        if (component != null) {
+            foreground = component.getForeground();
+            background = component.getBackground();
+            font = component.getFont();
+        }
+        if (foreground == null)
+            foreground = DEFAULT_COLOR;
+        if (background == null)
+            background = DEFAULT_COLOR;
+        if (font == null)
+            font = DEFAULT_FONT;
+        fontMetrics = BDFontMetrics.getFontMetrics(font);
+        composite = AlphaComposite.SrcOver;
+        setupClip();
+    }
+
+    public Graphics create() {
+        return new BDGraphics(this);
+    }
+
+    public java.awt.font.FontRenderContext getFontRenderContext()
+    {
+        return null;
+    }
+
+    public void translate(int x, int y) {
+        originX += x;
+        originY += y;
+    }
+
+    public void setFont(Font font) {
+        if (font != null && !font.equals(this.font)) {
+            this.font = font;
+            fontMetrics = BDFontMetrics.getFontMetrics(font);
+        }
+    }
+
+    public Font getFont() {
+        return font;
+    }
+
+    public FontMetrics getFontMetrics() {
+        return fontMetrics;
+    }
+
+    public FontMetrics getFontMetrics(Font font) {
+        return BDFontMetrics.getFontMetrics(font);
+    }
+
+    public void setColor(Color c) {
+        if ((c != null) && (c != foreground))
+            foreground = c;
+    }
+
+    public Color getColor() {
+        return foreground;
+    }
+
+    public void setPaint(Paint p) {
+        paint = p;
+    }
+    public Paint getPaint() {
+        return paint;
+    }
+    public void transform(java.awt.geom.AffineTransform t) {
+        logger.unimplemented("transform");
+    }
+    public void setTransform(java.awt.geom.AffineTransform t) {
+        logger.unimplemented("setTransform");
+    }
+    public java.awt.geom.AffineTransform getTransform() {
+        logger.unimplemented("getTransform");
+        throw new Error("Not implemented");
+    }
+    public void shear(double a, double b) {
+        logger.unimplemented("shear");
+    }
+    public void scale(double a, double b) {
+        logger.unimplemented("scale");
+    }
+    public void rotate(double a) {
+        logger.unimplemented("rotate");
+    }
+    public void rotate(double a, double b, double c) {
+        logger.unimplemented("rotate");
+    }
+    public void translate(double a, double b) {
+        logger.unimplemented("translate");
+    }
+    public boolean hit(Rectangle rect, Shape s, boolean onStroke)  {
+        logger.unimplemented("hit");
+        return true;
+    }
+    public void fill(Shape s) {
+        logger.unimplemented("fill");
+    }
+    public void draw(java.awt.Shape s) {
+        logger.unimplemented("draw");
+    }
+    public  void drawGlyphVector(GlyphVector g, float x, float y)  {
+        logger.unimplemented("drawGlyphVector");
+    }
+    public void setRenderingHints(java.util.Map hints) {
+        logger.unimplemented("setRenderingHints");
+    }
+    public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue) {
+        logger.unimplemented("setRenderingHint");
+    }
+    public void addRenderingHints(java.util.Map hints) {
+        logger.unimplemented("addRenderingHints");
+    }
+    public Object getRenderingHint(RenderingHints.Key hintKey) {
+        logger.unimplemented("getRenderingHint");
+        return null;
+    }
+    public RenderingHints getRenderingHints() {
+        logger.unimplemented("getRenderingHints");
+        return null;
+    }
+    public Composite getComposite() {
+        return composite;
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration() {
+        return gc;
+    }
+
+    public void setComposite(Composite comp) {
+        if ((comp != null) && (comp != composite)) {
+            if (!(comp instanceof AlphaComposite))
+                throw new IllegalArgumentException("Only AlphaComposite is supported");
+            composite = (AlphaComposite) comp;
+        }
+    }
+
+    public void setPaintMode() {
+        xorColor = null;
+    }
+
+    public void setXORMode(Color color) {
+        xorColor = color;
+    }
+
+    /** Gets the current clipping area. */
+    public Rectangle getClipBounds() {
+        if (clip != null)
+            return new Rectangle (clip.x - originX, clip.y - originY, clip.width, clip.height);
+        return null;
+    }
+
+    public void constrain(int x, int y, int w, int h) {
+        Rectangle rect;
+        if (constrainedRect != null)
+            rect = constrainedRect;
+        else
+            rect = new Rectangle(0, 0, width, height);
+        constrainedRect = rect.intersection(new Rectangle(rect.x + x, rect.y + y, w, h));
+        originX = constrainedRect.x;
+        originY = constrainedRect.y;
+        setupClip();
+    }
+
+    /** Returns a Shape object representing the clip. */
+    public Shape getClip() {
+        return getClipBounds();
+    }
+
+    /** Crops the clipping rectangle. */
+    public void clipRect(int x, int y, int w, int h) {
+        Rectangle rect = new Rectangle(x + originX, y + originY, w, h);
+        if (clip != null)
+            clip = clip.intersection(rect);
+        else
+            clip = rect;
+        setupClip();
+    }
+
+    /** Sets the clipping rectangle. */
+    public void setClip(int x, int y, int w, int h) {
+        clip = new Rectangle (x + originX, y + originY, w, h);
+        setupClip();
+    }
+
+    public void clip(Shape s) {
+        setClip(s);
+    }
+
+    /** Sets the clip to a Shape (only Rectangle allowed). */
+    public void setClip(Shape clip) {
+        if (clip == null) {
+            this.clip = null;
+            setupClip();
+        } else if (clip instanceof Rectangle) {
+            Rectangle rect = (Rectangle) clip;
+            setClip(rect.x, rect.y, rect.width, rect.height);
+        } else
+            throw new IllegalArgumentException("setClip(Shape) only supports Rectangle objects");
+    }
+
+    private void setupClip() {
+        Rectangle rect;
+        if (constrainedRect != null)
+            rect = constrainedRect;
+        else
+            rect = new Rectangle(0, 0, width, height);
+        if (clip != null)
+            actualClip = clip.intersection(rect);
+        else
+            actualClip = rect;
+    }
+
+    private int alphaBlend(int dest, int src) {
+        int As = src >>> 24;
+        if (As == 0)
+            return dest;
+        if (As == 255)
+            return src;
+        int Ad = (dest >>> 24);
+        if (Ad == 0)
+            return src;
+        int R, G, B;
+        R = ((src >>> 16) & 255) * As * 255;
+        G = ((src >>> 8) & 255) * As * 255;
+        B = (src & 255) * As * 255;
+        Ad = Ad * (255 - As);
+        As = As * 255 + Ad;
+        R = (R + ((dest >>> 16) & 255) * Ad) / As;
+        G = (G + ((dest >>> 8) & 255) * Ad) / As;
+        B = (B + (dest & 255) * Ad) / As;
+        R = Math.min(255, R);
+        G = Math.min(255, G);
+        B = Math.min(255, B);
+        Ad = As / 255;
+        Ad = Math.min(255, Ad);
+        return (Ad << 24) | (R << 16) | (G << 8) | B;
+    }
+
+    private void drawPointN(int x, int y, int rgb) {
+
+        dirty.add(x, y);
+
+        if (xorColor != null) {
+            backBuffer[y * width + x] ^= xorColor.getRGB() ^ rgb;
+            return;
+        }
+        int rule;
+        if (composite != null) {
+            rule = composite.getRule();
+            rgb = ((int)((rgb >>> 24) * composite.getAlpha()) << 24) | (rgb & 0x00FFFFFF);
+        } else {
+            rule = AlphaComposite.SRC_OVER;
+        }
+        switch (rule) {
+            case AlphaComposite.CLEAR:
+                backBuffer[y * width + x] = 0;
+                break;
+            case AlphaComposite.SRC:
+                backBuffer[y * width + x] = rgb;
+                break;
+            case AlphaComposite.SRC_OVER:
+                backBuffer[y * width + x] = alphaBlend(backBuffer[y * width + x], rgb);
+                break;
+        }
+    }
+
+    private void drawPoint(int x, int y, int rgb) {
+        x += originX;
+        y += originY;
+        if (actualClip.contains(x, y))
+            drawPointN(x, y, rgb);
+    }
+
+    public void clearRect(int x, int y, int w, int h) {
+        x += originX;
+        y += originY;
+        Rectangle rect = new Rectangle(x, y, w, h);
+        rect = actualClip.intersection(rect);
+        x = rect.x;
+        y = rect.y;
+        w = rect.width;
+        h = rect.height;
+        int rgb = background.getRGB();
+        for (int i = 0; i < h; i++)
+            Arrays.fill(backBuffer, (y + i) * width + x, (y + i) * width + x + w, rgb);
+
+        dirty.add(rect);
+    }
+
+    public void fillRect(int x, int y, int w, int h) {
+        x += originX;
+        y += originY;
+        Rectangle rect = new Rectangle(x, y, w, h);
+        rect = actualClip.intersection(rect);
+        x = rect.x;
+        y = rect.y;
+        w = rect.width;
+        h = rect.height;
+        int rgb = foreground.getRGB();
+        for (int Y = y; Y < (y + h); Y++)
+            for (int X = x; X < (x + w); X++)
+                drawPointN(X, Y, rgb);
+    }
+
+    public void drawRect(int x, int y, int w, int h) {
+        drawLineN(x, y, x + w, y);
+        drawLineN(x, y + h, x + w, y + h);
+        drawLineN(x, y, x, y + h);
+        drawLineN(x + w, y, x + w, y + h);
+    }
+
+    public void drawLineN(int x1, int y1, int x2, int y2) {
+        int rgb = foreground.getRGB();
+        int dy = y2 - y1;
+        int dx = x2 - x1;
+        int stepx, stepy;
+        int fraction;
+        if (dy < 0) {
+            dy = -dy;
+            stepy = -1;
+        } else {
+            stepy = 1;
+        }
+        if (dx < 0) {
+            dx = -dx;
+            stepx = -1;
+        } else {
+            stepx = 1;
+        }
+        dy <<= 1;
+        dx <<= 1;
+
+        drawPointN(x1, y1, rgb);
+
+        if (dx > dy) {
+            fraction = dy - (dx >> 1);
+            while (x1 != x2) {
+                if (fraction >= 0) {
+                    y1 += stepy;
+                    fraction -= dx;
+                }
+                x1 += stepx;
+                fraction += dy;
+                drawPointN(x1, y1, rgb);
+            }
+        } else {
+            fraction = dx - (dy >> 1);
+            while (y1 != y2) {
+                if (fraction >= 0) {
+                    x1 += stepx;
+                    fraction -= dy;
+                }
+                y1 += stepy;
+                fraction += dx;
+                drawPointN(x1, y1, rgb);
+            }
+        }
+    }
+
+    public void drawLine(int x1, int y1, int x2, int y2) {
+        drawLineN(x1, y1, x2, y2);
+    }
+
+    /**
+     * Copies an area of the canvas that this graphics context paints to.
+     * @param X the x-coordinate of the source.
+     * @param Y the y-coordinate of the source.
+     * @param W the width.
+     * @param H the height.
+     * @param dx the horizontal distance to copy the pixels.
+     * @param dy the vertical distance to copy the pixels.
+     */
+    public void copyArea(int X, int Y, int W, int H, int dx, int dy) {
+        X += originX;
+        Y += originY;
+        logger.unimplemented("copyArea");
+    }
+
+    /** Draws lines defined by an array of x points and y points */
+    public void drawPolyline(int xPoints[], int yPoints[], int nPoints) {
+        if (nPoints == 1) {
+            drawPointN(xPoints[0], yPoints[0], foreground.getRGB());
+        } else {
+            for (int i = 0; i < (nPoints - 1); i++)
+                drawLineN(xPoints[i], xPoints[i], xPoints[i + 1], xPoints[i + 1]);
+        }
+    }
+
+    /** Draws a polygon defined by an array of x points and y points */
+    public void drawPolygon(int xPoints[], int yPoints[], int nPoints) {
+        if (nPoints == 1) {
+            drawPointN(xPoints[0], yPoints[0], foreground.getRGB());
+        } else {
+            for (int i = 0; i < (nPoints - 1); i++)
+                drawLineN(xPoints[i], xPoints[i], xPoints[i + 1], xPoints[i + 1]);
+            if (nPoints > 2)
+                drawLineN(xPoints[0], xPoints[0], xPoints[nPoints - 1], xPoints[nPoints - 1]);
+        }
+    }
+
+    /** Fills a polygon with the current fill mask */
+    public void fillPolygon(int xPoints[], int yPoints[], int nPoints) {
+        logger.unimplemented("fillPolygon");
+    }
+
+    /** Draws an oval to fit in the given rectangle */
+    public void drawOval(int x, int y, int w, int h) {
+        logger.unimplemented("drawOval");
+    }
+
+    /** Fills an oval to fit in the given rectangle */
+    public void fillOval(int x, int y, int w, int h) {
+        logger.unimplemented("fillOval");
+    }
+
+    /**
+     * Draws an arc bounded by the given rectangle from startAngle to
+     * endAngle. 0 degrees is a vertical line straight up from the
+     * center of the rectangle. Positive start angle indicate clockwise
+     * rotations, negative angle are counter-clockwise.
+     */
+    public void drawArc(int x, int y, int w, int h, int startAngle, int endAngle) {
+        logger.unimplemented("drawArc");
+    }
+
+    /** fills an arc. arguments are the same as drawArc. */
+    public void fillArc(int x, int y, int w, int h, int startAngle, int endAngle) {
+        logger.unimplemented("fillArc");
+    }
+
+    /** Draws a rounded rectangle. */
+    public void drawRoundRect(int x, int y, int w, int h, int arcWidth, int arcHeight) {
+        logger.unimplemented("drawRoundRect");
+    }
+
+    /** Draws a filled rounded rectangle. */
+    public void fillRoundRect(int x, int y, int w, int h, int arcWidth, int arcHeight) {
+        logger.unimplemented("fillRoundRect");
+    }
+
+    protected native void drawStringN(long ftFace, String string, int x, int y, int rgb);
+
+    /** Draws the given string. */
+    public void drawString(String string, int x, int y) {
+        drawStringN(fontMetrics.ftFace, string, x, y, foreground.getRGB());
+    }
+
+    public void drawString(String string, float x, float y) {
+        drawStringN(fontMetrics.ftFace, string, (int)x, (int)y, foreground.getRGB());
+    }
+
+    public void drawRenderableImage(RenderableImage img, AffineTransform xform)  {
+        logger.unimplemented("drawRenaerableImage");
+    }
+
+    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
+        logger.unimplemented("drawRenaeredImage");
+    }
+
+    /** Draws the given character array. */
+    public void drawChars(char chars[], int offset, int length, int x, int y) {
+        drawStringN(fontMetrics.ftFace, new String(chars, offset, length), x, y, foreground.getRGB());
+    }
+
+    public void drawString(AttributedCharacterIterator arg0, int arg1, int arg2) {
+        logger.unimplemented("drawString");
+    }
+
+    public void drawString(AttributedCharacterIterator iterator, float x, float y) {
+        logger.unimplemented("drawString");
+    }
+
+    public void drawImage(java.awt.image.BufferedImage i,java.awt.image.BufferedImageOp o, int x, int y) {
+        logger.unimplemented("drawImage");
+    }
+
+    public boolean drawImage(java.awt.Image i, java.awt.geom.AffineTransform t, java.awt.image.ImageObserver o) {
+        logger.unimplemented("drawImage");
+        return true;
+    }
+
+    /**
+     * Draws an image at x,y in nonblocking mode with a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
+        return drawImage(img, x, y, null, observer);
+    }
+
+    /**
+     * Draws an image at x,y in nonblocking mode with a solid background
+     * color and a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, Color bg,
+        ImageObserver observer) {
+        return drawImageN(img, x, y, -1, -1, 0, 0, -1, -1, bg, observer);
+    }
+
+    /**
+     * Draws an image scaled to x,y,w,h in nonblocking mode with a
+     * callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, int w, int h,
+        ImageObserver observer) {
+        return drawImage(img, x, y, w, h, null, observer);
+    }
+
+    /**
+     * Draws an image scaled to x,y,w,h in nonblocking mode with a
+     * solid background color and a callback object.
+     */
+    public boolean drawImage(Image img, int x, int y, int w, int h,
+        Color bg, ImageObserver observer) {
+        return drawImageN(img, x, y, w, h, 0, 0, -1, -1, bg, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle
+     * in nonblocking mode with a callback object.
+     */
+    public boolean drawImage(Image img,
+        int dx1, int dy1, int dx2, int dy2,
+        int sx1, int sy1, int sx2, int sy2,
+        ImageObserver observer) {
+        return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle in
+     * nonblocking mode with a solid background color and a callback object.
+     */
+    public boolean drawImage(Image img,
+        int dx1, int dy1, int dx2, int dy2,
+        int sx1, int sy1, int sx2, int sy2,
+        Color bg, ImageObserver observer) {
+        if ((dx1 >= dx2) || (dy1 >= dy2))
+            return false;
+        return drawImageN(img, dx1, dy1, dx2 - dx1, dy2 - dy1,
+                          sx1, sy1, sx2 - sx1, sy2 - sy1, bg, observer);
+    }
+
+    /**
+     * Draws a subrectangle of an image scaled to a destination rectangle in
+     * nonblocking mode with a solid background color and a callback object.
+     */
+    protected boolean drawImageN(Image img,
+        int dx, int dy, int dw, int dh,
+        int sx, int sy, int sw, int sh,
+        Color bg, ImageObserver observer) {
+        if ((sx < 0) || (sy < 0) ||
+            (sw == 0) || (sh == 0) || (dw == 0) || (dh == 0))
+            return false;
+
+        BDImage bdImage;
+        if (img instanceof BDImage) {
+            bdImage = (BDImage)img;
+        } else if (img instanceof DVBBufferedImage) {
+            logger.unimplemented("drawImageN(DVBBufferedImage)");
+            //bdImage = (BDImage)getBufferedImagePeer(
+            //          (BufferedImage)(((DVBBufferedImage)img).getImage()));
+            bdImage = (BDImage)((DVBBufferedImage)img).getImage();
+        } else if (img instanceof BufferedImage) {
+            logger.unimplemented("drawImageN(BufferedImage)");
+            //bdImage = (BDImage)getBufferedImagePeer((BufferedImage)img);
+            return false;
+        } else {
+            logger.unimplemented("drawImageN(UNKNOWN)");
+            return false;
+        }
+        if (bdImage instanceof BDImageConsumer) {
+            BDImageConsumer consumer = (BDImageConsumer)bdImage;
+            if (!consumer.isComplete(observer)) {
+                return false;
+            }
+        }
+
+        if(sx + sw > bdImage.width) {
+            int n = sx + sw - bdImage.width;
+            dw -= dw * n / sw;
+            sw -= n;
+        }
+
+        if(sy + sh > bdImage.height) {
+            int n = sy + sh - bdImage.height;
+            dh -= dh * n / sh;
+            sh -= n;
+        }
+
+        if ((sw > 0) && (sh > 0) &&
+            ((sx != 0) || (sy != 0) || (sw != bdImage.width) || (sh != bdImage.height))) {
+            BDImage subImage = new BDImage(null, sw, sh, null);
+            bdImage.getRGB(sx, sy, sw, sh, subImage.getBdBackBuffer(), 0, sw);
+            bdImage = subImage;
+        }
+        if ((dw > 0) && (dh > 0) &&
+            ((dw != bdImage.width) || (dh != bdImage.height))) {
+            BDImageConsumer scaledImage = new BDImageConsumer(null);
+            AreaAveragingScaleFilter scaleFilter =
+                new AreaAveragingScaleFilter(dw, dh);
+            scaleFilter = (AreaAveragingScaleFilter)scaleFilter.getFilterInstance(scaledImage);
+            scaleFilter.setDimensions(bdImage.width, bdImage.height);
+            scaleFilter.setPixels(0, 0, bdImage.width, bdImage.height,
+                                  bdImage.getColorModel(), bdImage.getBdBackBuffer(),
+                                  0, bdImage.width);
+            scaleFilter.imageComplete(ImageConsumer.STATICIMAGEDONE);
+            bdImage = scaledImage;
+        }
+        int[] rgbArray = bdImage.getBdBackBuffer();
+        int bgColor;
+        if (bg != null)
+            bgColor = bg.getRGB();
+        else
+            bgColor = 0;
+        for (int y = dy; y < (dy + bdImage.height); y++)
+            for (int x = dx; x < (dx + bdImage.width); x++) {
+                if (bg != null)
+                    drawPoint(x, y, bgColor);
+                drawPoint(x, y, rgbArray[(y - dy) * bdImage.width + (x - dx)]);
+            }
+        return true;
+    }
+
+    public Stroke getStroke() {
+        logger.unimplemented("getStroke");
+        throw new Error();
+    }
+
+    public void setStroke(Stroke stroke) {
+        logger.unimplemented("setStroke");
+    }
+
+    public void dispose() {
+    }
+
+    public String toString() {
+        return getClass().getName() + "[" + originX + "," + originY + "]";
+    }
+
+    private static final Logger logger = Logger.getLogger(BDGraphics.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDImage.java libbluray/src/libbluray/bdj/java-j2se/java/awt/BDImage.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDImage.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/BDImage.java	2013-07-26 19:56:40.245605159 +0200
@@ -0,0 +1,26 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+class BDImage extends BDImageBase {
+    BDImage(Component component, int width, int height, GraphicsConfiguration gc) {
+        super(component, width, height, gc);
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDToolkit.java libbluray/src/libbluray/bdj/java-j2se/java/awt/BDToolkit.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/BDToolkit.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/BDToolkit.java	2013-07-26 18:40:43.505796387 +0200
@@ -0,0 +1,351 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ * Copyright (C) 2012  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt;
+
+import java.awt.image.ColorModel;
+import java.awt.image.ImageObserver;
+import java.awt.image.ImageProducer;
+import java.awt.peer.KeyboardFocusManagerPeer;
+import java.io.File;
+import java.net.URL;
+import java.util.Collections;
+import java.util.Hashtable;
+import java.util.WeakHashMap;
+import java.util.Map;
+import java.util.Iterator;
+
+import sun.awt.image.ByteArrayImageSource;
+import sun.awt.image.FileImageSource;
+import sun.awt.image.URLImageSource;
+import sun.awt.KeyboardFocusManagerPeerProvider;
+
+import java.awt.peer.BDFramePeer;
+import java.awt.peer.BDKeyboardFocusManagerPeer;
+
+import org.videolan.BDJXletContext;
+import org.videolan.Logger;
+
+public class BDToolkit extends Toolkit implements KeyboardFocusManagerPeerProvider {
+    private EventQueue eventQueue = new EventQueue();
+    private BDGraphicsEnvironment localEnv = new BDGraphicsEnvironment();
+    private BDGraphicsConfiguration defaultGC = (BDGraphicsConfiguration)localEnv.getDefaultScreenDevice().getDefaultConfiguration();
+    private static Hashtable cachedImages = new Hashtable();
+    private static final Logger logger = Logger.getLogger(BDToolkit.class.getName());
+
+    public BDToolkit () {
+    }
+
+    public static void shutdown() {
+        Toolkit toolkit = getDefaultToolkit();
+        if (toolkit instanceof BDToolkit) {
+            ((BDToolkit)toolkit).dispose();
+        }
+    }
+
+    public void dispose() {
+        if (eventQueue != null) {
+            BDJHelper.stopEventQueue(eventQueue);
+            eventQueue = null;
+        }
+
+        KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwner();
+        KeyboardFocusManager.getCurrentKeyboardFocusManager().setGlobalCurrentFocusCycleRoot(null);
+        KeyboardFocusManager.getCurrentKeyboardFocusManager().setGlobalFocusedWindow(null);
+        KeyboardFocusManager.getCurrentKeyboardFocusManager().setGlobalActiveWindow(null);
+        KeyboardFocusManager.getCurrentKeyboardFocusManager().setGlobalPermanentFocusOwner(null);
+
+        BDKeyboardFocusManagerPeer.shutdown();
+
+        KeyboardFocusManager.setCurrentKeyboardFocusManager(null);
+    }
+
+    public static void setFocusedWindow(Window window) {
+        /* hook KeyboardFocusManagerPeer (not doing this leads to crash) */
+        BDKeyboardFocusManagerPeer.init(window);
+    }
+
+    public KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager kfm)
+    {
+        return BDKeyboardFocusManagerPeer.getInstance();
+    }
+
+    public Dimension getScreenSize() {
+        Rectangle dims = defaultGC.getBounds();
+        return new Dimension(dims.width, dims.height);
+    }
+
+    Graphics getGraphics(Window window) {
+        if (!(window instanceof BDRootWindow)) {
+            System.err.println("getGraphics(): not BDRootWindow");
+            throw new Error("Not implemented");
+        }
+        return new BDWindowGraphics((BDRootWindow)window);
+    }
+
+    GraphicsEnvironment getLocalGraphicsEnvironment() {
+        return localEnv;
+    }
+
+    public int getScreenResolution() {
+        return 72;
+    }
+
+    public ColorModel getColorModel() {
+        return defaultGC.getColorModel();
+    }
+
+    public String[] getFontList() {
+        return BDFontMetrics.getFontList();
+    }
+
+    public FontMetrics getFontMetrics(Font font) {
+        return BDFontMetrics.getFontMetrics(font);
+    }
+
+    public void sync() {
+        org.videolan.GUIManager.getInstance().sync();
+    }
+
+    static void clearCache(BDImage image) {
+        synchronized (cachedImages) {
+            Iterator i = cachedImages.entrySet().iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry) i.next();
+                if (entry.getValue() == image) {
+                    i.remove();
+                    return;
+                }
+            }
+        }
+    }
+
+    public Image getImage(String filename) {
+        if (cachedImages.containsKey(filename))
+            return (Image)cachedImages.get(filename);
+        Image newImage = createImage(filename);
+        if (newImage != null)
+            cachedImages.put(filename, newImage);
+        return newImage;
+    }
+
+    public Image getImage(URL url) {
+        if (cachedImages.containsKey(url))
+            return (Image)cachedImages.get(url);
+        Image newImage = createImage(url);
+        if (newImage != null)
+            cachedImages.put(url, newImage);
+        return newImage;
+    }
+
+    public Image createImage(String filename) {
+        if (!new File(filename).exists()) {
+            BDJXletContext ctx = BDJXletContext.getCurrentContext();
+            if (ctx != null) {
+                ClassLoader cldr = (ClassLoader)ctx.getClassLoader();
+                URL url = cldr.getResource(filename);
+                if (url != null) {
+                    logger.warning("" + filename + " translated to " + url);
+                    return createImage(url);
+                } else {
+                    logger.error("ClassLoader failed to translate " + filename);
+                }
+            } else {
+                logger.error("createImage(" + filename + "): no XletContext available!\n" + logger.dumpStack());
+            }
+        }
+
+        ImageProducer ip = new FileImageSource(filename);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(URL url) {
+        ImageProducer ip = new URLImageSource(url);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(byte[] imagedata,
+        int imageoffset,
+        int imagelength) {
+        ImageProducer ip = new ByteArrayImageSource(imagedata, imageoffset, imagelength);
+        Image newImage = createImage(ip);
+        return newImage;
+    }
+
+    public Image createImage(ImageProducer producer) {
+        return new BDImageConsumer(producer);
+    }
+
+    public Image createImage(Component component, int width, int height) {
+        return new BDImage(component, width, height, defaultGC);
+   }
+
+    public boolean prepareImage(Image image, int width, int height, ImageObserver observer) {
+        if (!(image instanceof BDImageConsumer))
+            return true;
+        BDImageConsumer img = (BDImageConsumer)image;
+        return img.prepareImage(observer);
+    }
+
+    public int checkImage(Image image, int width, int height,
+        ImageObserver observer) {
+        if (!(image instanceof BDImageConsumer)) {
+            return ImageObserver.ALLBITS;
+        }
+        BDImageConsumer img = (BDImageConsumer)image;
+        return img.checkImage(observer);
+    }
+
+    public void beep() {
+    }
+
+    // mapping of Components to AppContexts, WeakHashMap<Component,AppContext>
+    private static final Map contextMap =
+        Collections.synchronizedMap(new WeakHashMap());
+
+    public static void addComponent(Component component) {
+
+        BDJXletContext context = BDJXletContext.getCurrentContext();
+        if (context == null) {
+            logger.warning("addComponent() outside of app context");
+            return;
+        }
+        contextMap.put(component, context);
+    }
+
+    public static EventQueue getEventQueue(Component component) {
+        if (component != null) {
+            do {
+                BDJXletContext ctx = (BDJXletContext)contextMap.get(component);
+                if (ctx != null) {
+                    EventQueue eq = ctx.getEventQueue();
+                    if (eq == null) {
+                        logger.warning("getEventQueue() failed: no context event queue");
+                    }
+                    return eq;
+                }
+
+                component = component.getParent();
+            } while (component != null);
+
+            logger.warning("getEventQueue() failed: no context");
+        }
+        return null;
+    }
+
+    protected EventQueue getSystemEventQueueImpl() {
+        BDJXletContext ctx = BDJXletContext.getCurrentContext();
+        if (ctx != null) {
+            EventQueue eq = ctx.getEventQueue();
+            if (eq != null) {
+                return eq;
+            }
+        }
+        return eventQueue;
+    }
+
+    public Map mapInputMethodHighlight(java.awt.im.InputMethodHighlight h) {
+        throw new Error("Not implemented");
+    }
+    public  boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType modalExclusionType) {
+        throw new Error("Not implemented");
+    }
+    public  boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.FramePeer createFrame(Frame target) {
+        return new BDFramePeer(target, (BDRootWindow)target);
+    }
+
+    protected java.awt.peer.ButtonPeer createButton(Button target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.CanvasPeer createCanvas(Canvas target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.CheckboxPeer createCheckbox(Checkbox target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.ChoicePeer createChoice(Choice target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.DesktopPeer createDesktopPeer(Desktop target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.DialogPeer createDialog(Dialog target) {
+        throw new Error("Not implemented");
+    }
+    public java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge) {
+        throw new Error("Not implemented");
+    }
+    public java.awt.peer.FileDialogPeer createFileDialog(FileDialog target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.LabelPeer createLabel(Label target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.ListPeer createList(List target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.MenuPeer createMenu(Menu target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.MenuBarPeer createMenuBar(MenuBar target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.MenuItemPeer createMenuItem(MenuItem target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.PanelPeer createPanel(Panel target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.PopupMenuPeer createPopupMenu(PopupMenu target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.ScrollbarPeer createScrollbar(Scrollbar target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.ScrollPanePeer createScrollPane(ScrollPane target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.TextAreaPeer createTextArea(TextArea target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.TextFieldPeer createTextField(TextField target) {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.WindowPeer createWindow(Window target) {
+        throw new Error("Not implemented");
+    }
+    public java.awt.datatransfer.Clipboard getSystemClipboard() {
+        throw new Error("Not implemented");
+    }
+    public PrintJob getPrintJob(Frame frame, String jobtitle, java.util.Properties props)  {
+        throw new Error("Not implemented");
+    }
+    protected java.awt.peer.FontPeer getFontPeer(String name, int style) {
+        throw new Error("Not implemented");
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDComponentPeer.java libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDComponentPeer.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDComponentPeer.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDComponentPeer.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,283 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt.peer;
+
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.image.*;
+
+import org.videolan.Logger;
+
+public abstract class BDComponentPeer implements ComponentPeer
+{
+    public BDComponentPeer(Toolkit toolkit, Component component) {
+        this.toolkit = toolkit;
+        this.component = component;
+        setBounds (component.getX(), component.getY(), component.getWidth(), component.getHeight(), SET_BOUNDS);
+    }
+
+    public void applyShape(sun.java2d.pipe.Region r) {
+    }
+
+    public boolean canDetermineObscurity() {
+        return false;
+    }
+
+    public int checkImage(Image img, int w, int h, ImageObserver o) {
+        return ((BDToolkit)toolkit).checkImage(img, w, h, o);
+    }
+
+    public void coalescePaintEvent(PaintEvent e) {
+    }
+
+    public void createBuffers(int x, BufferCapabilities bufferCapabilities) {
+        logger.unimplemented("createBuffers");
+    }
+
+    public Image createImage(ImageProducer producer) {
+        logger.unimplemented("createImage");
+        return null;
+    }
+
+    public Image createImage(int width, int height) {
+        Component parent = component.getParent();
+        if (parent != null) {
+            return parent.createImage(width, height);
+        }
+        logger.error("createImage(): no parent !");
+        throw new Error();
+    }
+
+    public VolatileImage createVolatileImage(int width, int height) {
+        logger.unimplemented("createVolatileImage");
+        return null;
+    }
+
+    public void destroyBuffers() {
+    }
+
+    /* java 6 only */
+    public void disable() {
+        setEnabled(false);
+    }
+
+    public void dispose() {
+        component = null;
+        toolkit = null;
+    }
+
+    /* java 6 only */
+    public void enable() {
+        setEnabled(true);
+    }
+
+    public void flip(int a, int b, int c, int d, java.awt.BufferCapabilities.FlipContents e) {
+    }
+
+    /* java 6 only */
+    public Rectangle getBounds() {
+        return new Rectangle(location.x, location.y, size.width, size.height);
+        //rootWindow.getBounds();
+    }
+
+    public Image getBackBuffer() {
+        logger.unimplemented("getBackBuffer");
+        throw new Error();
+    }
+
+    public ColorModel getColorModel() {
+        return toolkit.getColorModel();
+    }
+
+    public FontMetrics getFontMetrics(Font font) {
+        logger.unimplemented("getFontMetrics");
+        return null;
+    }
+
+    public Graphics getGraphics() {
+        Component parent = component.getParent();
+        if (parent != null) {
+            return parent.getGraphics().create(location.x, location.y, size.width, size.height);
+        }
+        logger.error("getGraphics(): no parent !");
+        throw new Error();
+    }
+
+    public GraphicsConfiguration getGraphicsConfiguration() {
+        logger.unimplemented("getGraphicsConfiguration");
+        return null;
+    }
+
+    public Point getLocationOnScreen() {
+        Point screen = new Point(location);
+        Component parent = component.getParent();
+        if (parent != null) {
+            Point parentScreen = parent.getLocationOnScreen();
+            screen.translate(parentScreen.x, parentScreen.y);
+        }
+        return screen;
+    }
+
+    public Dimension getMinimumSize() {
+        return size;
+    }
+
+    public Dimension getPreferredSize() {
+        return size;
+    }
+
+    public Toolkit getToolkit() {
+        return toolkit;
+    }
+
+    public void handleEvent(AWTEvent e) {
+        int id = e.getID();
+
+        if (e instanceof PaintEvent) {
+            Graphics g = null;
+            Rectangle r = ((PaintEvent)e).getUpdateRect();
+            try {
+                g = component.getGraphics();
+                if (g == null)
+                    return;
+                g.clipRect(r.x, r.y, r.width, r.height);
+                if (id == PaintEvent.PAINT)
+                    component.paint(g);
+                else
+                    component.update(g);
+                toolkit.sync();
+            } finally {
+                if (g != null)
+                    g.dispose();
+            }
+        }
+    }
+
+    public boolean handlesWheelScrolling() {
+        return false;
+    }
+
+    /* java 6 only */
+    public void hide() {
+        setVisible(false);
+    }
+
+    public boolean isFocusable() {
+        return true;
+    }
+
+    public boolean isObscured() {
+        return false;
+    }
+
+    public boolean isReparentSupported() {
+        return false;
+    }
+
+    public void layout() {
+    }
+
+    /* java 1.6 only */
+    public Dimension minimumSize() {
+        return getMinimumSize();
+    }
+
+    public void paint(Graphics g) {
+        component.paint(g);
+    }
+
+    /* java 1.6 only */
+    public Dimension preferredSize() {
+        return getPreferredSize();
+    }
+
+    public boolean prepareImage(Image img, int w, int h, ImageObserver o) {
+        return ((BDToolkit)toolkit).prepareImage(img, w, h, o);
+    }
+
+    public void print(Graphics g) {
+    }
+
+    /* java 1.6 only */
+    public void repaint(long tm, int x, int y, int width, int height) {
+        logger.unimplemented("repaint");
+    }
+
+    public void reparent(ContainerPeer p) {
+    }
+
+    /* java 1.6 only */
+    public void reshape(int x, int y, int width, int height) {
+        setBounds(x, y, width, height, SET_BOUNDS);
+    }
+
+    public boolean requestFocus(Component lightweightChild, boolean temporary, boolean focusedWindowChangeAllowed, long time) {
+        return true;
+    }
+
+
+    public void setBackground(Color c) {
+    }
+
+    public void setBounds(int x, int y, int width, int height, int op) {
+        location.x = x;
+        location.y = y;
+        size.width = width;
+        size.height = height;
+    }
+
+    public void setEnabled(boolean b) {
+        logger.unimplemented("setEnabled");
+    }
+
+    public void setFont(Font f) {
+    }
+
+    public void setForeground(Color c) {
+    }
+
+    public void setVisible(boolean b) {
+    }
+
+    /* java 7 */
+    public void setZOrder(ComponentPeer peer) {
+    }
+
+    /* java 6 only */
+    public void show() {
+        setVisible(true);
+    }
+
+    public void updateCursorImmediately() {
+    }
+
+    /* java 7 */
+    public boolean updateGraphicsData(GraphicsConfiguration gc) {
+        return false;
+    }
+
+
+    protected Component component;
+    protected Toolkit toolkit;
+    protected Point location = new Point();
+    protected Dimension size = new Dimension();
+
+    private static final Logger logger = Logger.getLogger(BDComponentPeer.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDFramePeer.java libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDFramePeer.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDFramePeer.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDFramePeer.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,193 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt.peer;
+
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.image.BufferedImage;
+
+import org.videolan.Logger;
+
+public class BDFramePeer extends BDComponentPeer implements FramePeer
+{
+    public BDFramePeer(Frame frame, BDRootWindow rootWindow) {
+        super(frame.getToolkit(), frame);
+        this.rootWindow = rootWindow;
+    }
+
+    public Rectangle getBoundsPrivate() {
+        return null;
+    }
+
+    public int getState() {
+        return Frame.NORMAL;
+    }
+
+    public void setBoundsPrivate(int a, int b, int c, int d) {
+    }
+
+    public void setMaximizedBounds(Rectangle bounds) {
+    }
+
+    public void setMenuBar(MenuBar mb) {
+    }
+
+    public void setResizable(boolean resizeable) {
+    }
+
+    public void setState(int state) {
+    }
+
+    public void setTitle(String title) {
+    }
+
+    //
+    // ContainerPeer
+    //
+
+    public void beginLayout() {
+    }
+
+    public void beginValidate() {
+    }
+
+    public void endLayout() {
+    }
+
+    public void endValidate() {
+    }
+
+    public Insets getInsets() {
+        return insets;
+    }
+
+    /* java 1.6 only */
+    public Insets insets() {
+        return getInsets();
+    }
+
+    /* java 1.6 only */
+    public boolean isPaintPending() {
+        return false;
+    }
+
+    /* java 1.6 only */
+    public boolean isRestackSupported() {
+        return false;
+    }
+
+    /* java 1.6 only */
+    public void restack() {
+    }
+
+    //
+    // WindowPeer
+    //
+
+    public void repositionSecurityWarning() {
+    }
+
+    /* Removed in java 1.6 update 45 */
+    public void setAlwaysOnTop(boolean b) {
+    }
+
+    /* java 1.6 update 45. Also in java 7 / 8. */
+    public void updateAlwaysOnTopState() {
+    }
+
+    public void setModalBlocked(Dialog d,boolean b) {
+    }
+
+    public void setOpacity(float f) {
+    }
+
+    public void setOpaque(boolean b) {
+    }
+
+    public void toBack() {
+    }
+
+    public void toFront() {
+    }
+
+    public void updateFocusableWindowState() {
+    }
+
+    public void updateIconImages() {
+    }
+
+    public void updateMinimumSize() {
+    }
+
+    public void updateWindow(BufferedImage b) {
+        logger.unimplemented("updateWindow");
+    }
+
+    /* java 1.7 ? */
+    public void updateWindow() {
+        logger.unimplemented("updateWindow");
+    }
+
+    /* java 1.6 only */
+    public boolean requestWindowFocus()  {
+        return true;
+    }
+
+    //
+    // ComponentPeer
+    //
+
+    //public Rectangle getBounds() {
+    //    return rootWindow.getBounds();
+    //}
+
+    public Graphics getGraphics() {
+        return new BDWindowGraphics(rootWindow);
+    }
+
+    public Image createImage(int width, int height) {
+        return ((BDToolkit)BDToolkit.getDefaultToolkit()).createImage((Component)null, width, height);
+    }
+
+    public boolean requestFocus(Component c, boolean a, boolean b, long l, sun.awt.CausedFocusEvent.Cause d) {
+        if (c == null) {
+            return true;
+        }
+        Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(new FocusEvent(c, FocusEvent.FOCUS_GAINED));
+        return true;
+    }
+
+    public void setVisible(boolean b) {
+        //Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(new WindowEvent((Frame)component, WindowEvent.WINDOW_ACTIVATED));
+        if (b == true) {
+            component.paint(getGraphics());
+        }
+    }
+
+    public void dispose() {
+        super.dispose();
+        rootWindow = null;
+    }
+
+    private BDRootWindow rootWindow;
+    private Insets insets = new Insets(0, 0, 0, 0);
+
+    private static final Logger logger = Logger.getLogger(BDFramePeer.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDKeyboardFocusManagerPeer.java libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDKeyboardFocusManagerPeer.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDKeyboardFocusManagerPeer.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDKeyboardFocusManagerPeer.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,121 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt.peer;
+
+import java.awt.Component;
+import java.awt.KeyboardFocusManager;
+import java.awt.Window;
+import java.lang.reflect.Field;
+
+public class BDKeyboardFocusManagerPeer implements KeyboardFocusManagerPeer {
+    private static boolean java7 = false;
+    static BDKeyboardFocusManagerPeer instance = null;
+
+    /* used in java 7 only */
+    public static KeyboardFocusManagerPeer getInstance() {
+        java7 = true;
+
+        if (instance == null) {
+            instance = new BDKeyboardFocusManagerPeer();
+        }
+        return instance;
+    }
+
+    public static void shutdown()
+    {
+        if (instance != null) {
+            instance.dispose();
+            instance = null;
+        }
+    }
+
+    public static void init(Window window)
+    {
+        /* running in java 7 ? */
+        if (java7 == true)
+            return;
+
+        if (instance == null)
+            instance = new BDKeyboardFocusManagerPeer();
+        instance.focusOwner = null;
+        instance.window = window;
+
+        /* replace default keyboard focus manager peer */
+        Field kbPeer;
+        try {
+            Class c = Class.forName("java.awt.KeyboardFocusManager");
+            kbPeer = c.getDeclaredField("peer");
+            kbPeer.setAccessible(true);
+        } catch (ClassNotFoundException e) {
+            throw new Error("java.awt.KeyboardFocusManager not found");
+        } catch (SecurityException e) {
+            throw new Error("java.awt.KeyboardFocusManager not accessible");
+        } catch (NoSuchFieldException e) {
+            throw new Error("java.awt.KeyboardFocusManager.peer not found");
+        }
+        try {
+            kbPeer.set(KeyboardFocusManager.getCurrentKeyboardFocusManager(),
+                       instance);
+        } catch (java.lang.IllegalAccessException e) {
+            throw new Error("java.awt.KeyboardFocusManager.peer not accessible:" + e);
+        }
+    }
+
+    private Component focusOwner = null;
+    private Window window = null; /* used in java 6 only */
+    private boolean disposed = false;
+
+    public void dispose()
+    {
+        focusOwner = null;
+        window = null;
+        disposed = true;
+    }
+
+    private BDKeyboardFocusManagerPeer() {
+    }
+
+    public void clearGlobalFocusOwner(Window w) {
+    }
+
+    public Component getCurrentFocusOwner() {
+        return focusOwner;
+    }
+
+    public void setCurrentFocusOwner(Component c) {
+        if (!disposed) {
+            focusOwner = c;
+        }
+    }
+
+    /* java 6 only */
+    public void setCurrentFocusedWindow(Window w) {
+        if (!disposed) {
+            window = w;
+        }
+    }
+
+    /* java 6 only */
+    public Window getCurrentFocusedWindow() {
+        return window;
+    }
+};
+
+
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDLightweightComponentPeer.java libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDLightweightComponentPeer.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/java/awt/peer/BDLightweightComponentPeer.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/java/awt/peer/BDLightweightComponentPeer.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,30 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package java.awt.peer;
+
+import java.awt.Toolkit;
+import java.awt.Component;
+
+public abstract class BDLightweightComponentPeer extends BDComponentPeer implements LightweightPeer
+{
+    public BDLightweightComponentPeer(Toolkit toolkit, Component component) {
+        super(toolkit, component);
+    }
+}
\ Brak znaku nowej linii na kocu pliku
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/io/ixc/IxcRegistry.java libbluray/src/libbluray/bdj/java-j2se/org/dvb/io/ixc/IxcRegistry.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/io/ixc/IxcRegistry.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/org/dvb/io/ixc/IxcRegistry.java	2013-07-26 19:56:40.245605159 +0200
@@ -0,0 +1,204 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  William Hahne
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.io.ixc;
+
+import java.rmi.RemoteException;
+import java.rmi.NotBoundException;
+import java.rmi.AlreadyBoundException;
+import java.rmi.Remote;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import javax.tv.xlet.XletContext;
+
+import org.dvb.application.AppID;
+import org.dvb.application.AppProxy;
+import org.dvb.application.AppsDatabase;
+
+import org.videolan.BDJXletContext;
+import org.videolan.Logger;
+
+public class IxcRegistry {
+    public static Remote lookup(XletContext xc, String path) throws NotBoundException, RemoteException {
+        logger.info("Lookup " + path);
+        logger.warning("Lookup does not create proxy object !");
+        int orgid, appid;
+        int s1, s2;
+        String name;
+        logger.info("Lookup " + path);
+        if (path.charAt(0) != '/')
+            throw new IllegalArgumentException();
+        s1 = path.indexOf('/', 1);
+        if (s1 <= 1)
+            throw new IllegalArgumentException();
+        try {
+            orgid = Integer.parseInt(path.substring(1, s1), 16);
+        } catch (Exception e) {
+            throw new IllegalArgumentException();
+        }
+        s1++;
+        s2 = path.indexOf('/', s1);
+        if (s2 <= s1)
+            throw new IllegalArgumentException();
+        try {
+            appid = Integer.parseInt(path.substring(s1, s2), 16);
+        } catch (Exception e) {
+            throw new IllegalArgumentException();
+        }
+        name = path.substring(s2 + 1, path.length());
+        String key = "/" + Integer.toHexString(orgid) +
+                "/" + Integer.toHexString(appid) +
+                "/" + name;
+
+        logger.info("Lookup " + key + " - path OK");
+        /*
+        String[] parts = path.split("/", 3);
+
+        if (parts.length != 3)
+            throw new IllegalArgumentException("Malformed path");
+
+        int orgId = Integer.parseInt(parts[0], 16);
+        short appId = Short.parseShort(parts[1], 16);
+        String name = parts[2];
+
+        for (int i = 0; i < ixcList.size(); i++) {
+            IxcObject obj = (IxcObject)ixcList.get(i);
+            if (obj.orgId == orgId && obj.appId == appId && obj.name.equals(name)) {
+                logger.info("Looked up " + path);
+                return obj.obj;
+            }
+        }
+        */
+        logger.warning("Failed to look up " + path);
+        throw new NotBoundException();
+    }
+
+    public static void bind(XletContext xc, String name, Remote obj) throws AlreadyBoundException {
+        logger.info("Bind " + name);
+        if (xc == null || name == null || obj == null)
+            throw new NullPointerException();
+
+        // make sure the xlet is not currently in the destroyed state
+        String orgid = (String)xc.getXletProperty("dvb.org.id");
+        String appid = (String)xc.getXletProperty("dvb.app.id");
+        AppID id = new AppID(Integer.parseInt(orgid, 16), Integer.parseInt(appid, 16));
+        if (AppsDatabase.getAppsDatabase().getAppProxy(id).getState() == AppProxy.DESTROYED)
+            return;
+
+        int orgId = id.getOID();
+        int iappId = id.getAID();
+        int appId = iappId;
+
+        IxcObject ixcObj = new IxcObject(orgId, appId, name, obj);
+
+        if (ixcList.contains(ixcObj))
+            throw new AlreadyBoundException();
+
+        ixcList.add(ixcObj);
+
+        logger.info("Bound /" + orgid + "/" + appid + "/" + name);
+    }
+
+    public static void unbind(XletContext xc, String name) throws NotBoundException {
+        logger.info("Unbind " + name);
+        if (xc == null || name == null)
+            throw new NullPointerException();
+
+        String orgid = (String)xc.getXletProperty("dvb.org.id");
+        String appid = (String)xc.getXletProperty("dvb.app.id");
+        int orgId = Integer.parseInt(orgid, 16);
+        int iappId = Integer.parseInt(appid, 16);
+        short appId = (short)iappId;
+
+        IxcObject ixcObj = new IxcObject(orgId, appId, name, null);
+
+        if (!ixcList.contains(ixcObj))
+            throw new NotBoundException();
+
+        ixcList.remove(ixcObj);
+
+        logger.info("Unbound /" + Integer.toString(orgId, 16) + "/" + Integer.toString(appId, 16) + "/" + name);
+    }
+
+    public static void rebind(XletContext xc, String name, Remote obj) {
+        try {
+            unbind(xc, name);
+        } catch (NotBoundException e) {
+            // ignore
+        }
+
+        try {
+            bind(xc, name, obj);
+        } catch (AlreadyBoundException e) {
+            logger.warning("rebind should never encounter an AlreadyBoundException, something is wrong here.");
+            e.printStackTrace();
+        }
+    }
+
+    public static String[] list(XletContext xc) {
+        String[] out = new String[ixcList.size()];
+
+        for (int i = 0; i < ixcList.size(); i++) {
+            IxcObject obj = (IxcObject)ixcList.get(i);
+
+            out[i] = "/" + Integer.toString(obj.orgId, 16) + "/" + Integer.toString(obj.appId, 16) + "/" + obj.name;
+        }
+
+        return out;
+    }
+
+    private static class IxcObject {
+        public IxcObject(int orgId, int appId, String name, Remote obj) {
+            this.orgId = orgId;
+            this.appId = appId;
+            this.name = name;
+            this.obj = obj;
+        }
+
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            IxcObject other = (IxcObject) obj;
+            if (appId != other.appId)
+                return false;
+            if (name == null) {
+                if (other.name != null)
+                    return false;
+            } else if (!name.equals(other.name))
+                return false;
+            if (orgId != other.orgId)
+                return false;
+            return true;
+        }
+
+        public int orgId;
+        public int appId;
+        public String name;
+        public Remote obj;
+    }
+
+    private static List ixcList = Collections.synchronizedList(new ArrayList());
+    private static Logger logger = Logger.getLogger(IxcRegistry.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/ui/DVBGraphicsImpl.java libbluray/src/libbluray/bdj/java-j2se/org/dvb/ui/DVBGraphicsImpl.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/ui/DVBGraphicsImpl.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/org/dvb/ui/DVBGraphicsImpl.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,512 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.ui;
+
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Paint;
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Shape;
+import java.awt.Stroke;
+import java.awt.font.FontRenderContext;
+import java.awt.font.GlyphVector;
+import java.awt.geom.AffineTransform;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
+import java.awt.image.ImageObserver;
+import java.awt.image.RenderedImage;
+import java.awt.image.renderable.RenderableImage;
+import java.text.AttributedCharacterIterator;
+import java.util.Map;
+
+public class DVBGraphicsImpl extends DVBGraphics {
+    protected DVBGraphicsImpl(Graphics2D gfx)
+    {
+        super(gfx);
+    }
+
+    /*
+     * Graphics methods
+     */
+    public void clearRect(int x, int y, int width, int height)
+    {
+        gfx.clearRect(x, y, width, height);
+    }
+
+    public void clipRect(int x, int y, int width, int height)
+    {
+        gfx.clipRect(x, y, width, height);
+    }
+
+    public void copyArea(int x, int y, int width, int height, int dx, int dy)
+    {
+        gfx.copyArea(x, y, width, height, dx, dy);
+    }
+
+    public Graphics create()
+    {
+        return gfx.create();
+    }
+
+    public Graphics create(int x, int y, int width, int height)
+    {
+        return gfx.create(x, y, width, height);
+    }
+
+    public void dispose()
+    {
+        gfx.dispose();
+    }
+
+    public void draw3DRect(int x, int y, int width, int height, boolean raised)
+    {
+        gfx.draw3DRect(x, y, width, height, raised);
+    }
+
+    public void drawArc(int x, int y, int width, int height, int startAngle,
+            int arcAngle)
+    {
+        gfx.drawArc(x, y, width, height, startAngle, arcAngle);
+    }
+
+    public void drawBytes(byte[] data, int offset, int length, int x, int y)
+    {
+        gfx.drawBytes(data, offset, length, x, y);
+    }
+
+    public void drawChars(char[] data, int offset, int length, int x, int y)
+    {
+        gfx.drawChars(data, offset, length, x, y);
+    }
+
+    public boolean drawImage(Image img, int x, int y, Color bgcolor,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, int width, int height,
+            Color bgcolor, ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, width, height, bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int x, int y, int width, int height,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, x, y, width, height, observer);
+    }
+
+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,
+            int sx1, int sy1, int sx2, int sy2, Color bgcolor,
+            ImageObserver observer)
+    {
+        return gfx.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
+                             bgcolor, observer);
+    }
+
+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,
+            int sx1, int sy1, int sx2, int sy2, ImageObserver observer)
+    {
+        return gfx.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
+                             observer);
+    }
+
+    public void drawLine(int x1, int y1, int x2, int y2)
+    {
+        gfx.drawLine(x1, y1, x2, y2);
+    }
+
+    public void drawOval(int x, int y, int width, int height)
+    {
+        gfx.drawOval(x, y, width, height);
+    }
+
+    public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.drawPolygon(xPoints, yPoints, nPoints);
+    }
+
+    public void drawPolygon(Polygon p)
+    {
+        gfx.drawPolygon(p);
+    }
+
+    public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.drawPolyline(xPoints, yPoints, nPoints);
+    }
+
+    public void drawRect(int x, int y, int width, int height)
+    {
+        gfx.drawRect(x, y, width, height);
+    }
+
+    public void drawRoundRect(int x, int y, int width, int height,
+            int arcWidth, int arcHeight)
+    {
+        gfx.drawRoundRect(x, y, width, height, arcWidth, arcHeight);
+    }
+
+    public void drawString(AttributedCharacterIterator iterator, int x, int y)
+    {
+        gfx.drawString(iterator, x, y);
+    }
+
+    public void drawString(String str, int x, int y)
+    {
+        gfx.drawString(str, x, y);
+    }
+
+    public void fill3DRect(int x, int y, int width, int height, boolean raised)
+    {
+        gfx.fill3DRect(x, y, width, height, raised);
+    }
+
+    public void fillArc(int x, int y, int width, int height, int startAngle,
+            int arcAngle)
+    {
+        gfx.fillArc(x, y, width, height, startAngle, arcAngle);
+    }
+
+    public void fillOval(int x, int y, int width, int height)
+    {
+        gfx.fillOval(x, y, width, height);
+    }
+
+    public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)
+    {
+        gfx.fillPolygon(xPoints, yPoints, nPoints);
+    }
+
+    public void fillPolygon(Polygon p)
+    {
+        gfx.fillPolygon(p);
+    }
+
+    public void fillRect(int x, int y, int width, int height)
+    {
+        gfx.fillRect(x, y, width, height);
+    }
+
+    public void fillRoundRect(int x, int y, int width, int height,
+            int arcWidth, int arcHeight)
+    {
+        gfx.fillRoundRect(x, y, width, height, arcWidth, arcHeight);
+    }
+
+    public void finalize()
+    {
+        gfx.finalize();
+    }
+
+    public Shape getClip()
+    {
+        return gfx.getClip();
+    }
+
+    public Rectangle getClipBounds()
+    {
+        return gfx.getClipBounds();
+    }
+
+    public Rectangle getClipBounds(Rectangle r)
+    {
+        return gfx.getClipBounds(r);
+    }
+
+    public Rectangle getClipRect()
+    {
+        return gfx.getClipRect();
+    }
+
+    public Color getColor()
+    {
+        return gfx.getColor();
+    }
+
+    public Font getFont()
+    {
+        return gfx.getFont();
+    }
+
+    public FontMetrics getFontMetrics()
+    {
+        return gfx.getFontMetrics();
+    }
+
+    public FontMetrics getFontMetrics(Font f)
+    {
+        return gfx.getFontMetrics(f);
+    }
+
+    public boolean hitClip(int x, int y, int width, int height)
+    {
+        return gfx.hitClip(x, y, width, height);
+    }
+
+    public void setClip(int x, int y, int width, int height)
+    {
+        gfx.setClip(x, y, width, height);
+    }
+
+    public void setClip(Shape clip)
+    {
+        gfx.setClip(clip);
+    }
+
+    public void setColor(Color c)
+    {
+        gfx.setColor(c);
+    }
+
+    public void setFont(Font font)
+    {
+        gfx.setFont(font);
+    }
+
+    public void setPaintMode()
+    {
+        gfx.setPaintMode();
+    }
+
+    public void setXORMode(Color c1)
+    {
+        gfx.setXORMode(c1);
+    }
+
+    public void translate(int x, int y)
+    {
+        gfx.translate(x, y);
+    }
+
+    /*
+     * DVBGraphics methods
+     */
+    public int[] getAvailableCompositeRules()
+    {
+        int[] rules = { DVBAlphaComposite.CLEAR, DVBAlphaComposite.SRC,
+                        DVBAlphaComposite.SRC_OVER, DVBAlphaComposite.DST_OVER,
+                        DVBAlphaComposite.SRC_IN, DVBAlphaComposite.DST_IN,
+                        DVBAlphaComposite.SRC_OUT, DVBAlphaComposite.DST_OUT };
+
+        return rules;
+    }
+
+    public DVBAlphaComposite getDVBComposite()
+    {
+        return alphaComposite;
+    }
+
+    public void setDVBComposite(DVBAlphaComposite comp)
+            throws UnsupportedDrawingOperationException
+    {
+        this.alphaComposite = comp;
+    }
+
+    /*
+     * Graphics2D methods
+     */
+    public void addRenderingHints(Map hints)
+    {
+        gfx.addRenderingHints(hints);
+    }
+
+    public void clip(Shape s)
+    {
+        gfx.clip(s);
+    }
+
+    public void draw(Shape s)
+    {
+        gfx.draw(s);
+    }
+
+    public void drawGlyphVector(GlyphVector g, float x, float y)
+    {
+        gfx.drawGlyphVector(g, x, y);
+    }
+
+    public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)
+    {
+        gfx.drawImage(img, op, x, y);
+    }
+
+    public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)
+    {
+        return gfx.drawImage(img, xform, obs);
+    }
+
+    public void drawRenderableImage(RenderableImage img, AffineTransform xform)
+    {
+        gfx.drawRenderableImage(img, xform);
+    }
+
+    public void drawRenderedImage(RenderedImage img, AffineTransform xform)
+    {
+        gfx.drawRenderedImage(img, xform);
+    }
+
+    public void drawString(AttributedCharacterIterator iterator, float x,
+            float y)
+    {
+        gfx.drawString(iterator, x, y);
+    }
+
+    public void drawString(String str, float x, float y)
+    {
+        gfx.drawString(str, x, y);
+    }
+
+    public void fill(Shape s)
+    {
+        gfx.fill(s);
+    }
+
+    public Color getBackground()
+    {
+        return gfx.getBackground();
+    }
+
+    public Composite getComposite()
+    {
+        return gfx.getComposite();
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration()
+    {
+        return gfx.getDeviceConfiguration();
+    }
+
+    public FontRenderContext getFontRenderContext()
+    {
+        return gfx.getFontRenderContext();
+    }
+
+    public Paint getPaint()
+    {
+        return gfx.getPaint();
+    }
+
+    public Object getRenderingHint(RenderingHints.Key hintKey)
+    {
+        return gfx.getRenderingHint(hintKey);
+    }
+
+    public RenderingHints getRenderingHints()
+    {
+        return gfx.getRenderingHints();
+    }
+
+    public Stroke getStroke()
+    {
+        return gfx.getStroke();
+    }
+
+    public AffineTransform getTransform()
+    {
+        return gfx.getTransform();
+    }
+
+    public boolean hit(Rectangle rect, Shape s, boolean onStroke)
+    {
+        return gfx.hit(rect, s, onStroke);
+    }
+
+    public void rotate(double theta)
+    {
+        gfx.rotate(theta);
+    }
+
+    public void rotate(double theta, double x, double y)
+    {
+        gfx.rotate(theta, x, y);
+    }
+
+    public void scale(double sx, double sy)
+    {
+        gfx.scale(sx, sy);
+    }
+
+    public void setBackground(Color color)
+    {
+        gfx.setBackground(color);
+    }
+
+    public void setComposite(Composite comp)
+    {
+        gfx.setComposite(comp);
+    }
+
+    public void setPaint(Paint paint)
+    {
+        gfx.setPaint(paint);
+    }
+
+    public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)
+    {
+        gfx.setRenderingHint(hintKey, hintValue);
+    }
+
+    public void setRenderingHints(Map hints)
+    {
+        gfx.setRenderingHints(hints);
+    }
+
+    public void setStroke(Stroke s)
+    {
+        gfx.setStroke(s);
+    }
+
+    public void setTransform(AffineTransform Tx)
+    {
+        gfx.setTransform(Tx);
+    }
+
+    public void shear(double shx, double shy)
+    {
+        gfx.shear(shx, shy);
+    }
+
+    public void transform(AffineTransform Tx)
+    {
+        gfx.transform(Tx);
+    }
+
+    public void translate(double tx, double ty)
+    {
+        gfx.translate(tx, ty);
+    }
+
+    private DVBAlphaComposite alphaComposite = DVBAlphaComposite.Clear;
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/ui/FontFactory.java libbluray/src/libbluray/bdj/java-j2se/org/dvb/ui/FontFactory.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/org/dvb/ui/FontFactory.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/org/dvb/ui/FontFactory.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,89 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2010  William Hahne
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.dvb.ui;
+
+import java.awt.Font;
+import java.awt.FontFormatException;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+
+import org.videolan.BDJException;
+import org.videolan.BDJUtil;
+import org.videolan.FontIndex;
+import org.videolan.FontIndexData;
+import org.videolan.Logger;
+
+public class FontFactory {
+    public static void loadDiscFonts() {
+        unloadDiscFonts();
+    }
+
+    public static void unloadDiscFonts() {
+    }
+
+    public FontFactory() throws FontFormatException, IOException {
+        String path = BDJUtil.discRootToFilesystem("/BDMV/AUXDATA/dvb.fontindex");
+
+        FontIndexData fontIndexData[] = FontIndex.parseIndex(path);
+
+        fonts = new HashMap(fontIndexData.length);
+        for (int i = 0; i < fontIndexData.length; i++) {
+            FontIndexData data = fontIndexData[i];
+            FileInputStream inStream = new FileInputStream(BDJUtil.discRootToFilesystem("/BDMV/AUXDATA/" + data.getFileName()));
+
+            Font font = Font.createFont(Font.TRUETYPE_FONT, inStream);
+            font = font.deriveFont(data.getStyle(), data.getMaxSize());
+
+            fonts.put(data.getName(), font);
+        }
+    }
+
+    public FontFactory(URL u) throws IOException, FontFormatException {
+        FileInputStream inStream = new FileInputStream(u.getPath());
+
+        urlFont = Font.createFont(Font.TRUETYPE_FONT, inStream);
+    }
+
+    public Font createFont(String name, int style, int size)
+            throws FontNotAvailableException, FontFormatException, IOException {
+        logger.info("Creating font: " + name + " " + style + " " + size);
+
+        if (urlFont != null && name.equals(urlFont.getName()))
+        {
+            return urlFont.deriveFont(style, size);
+        }
+
+        Font font = (Font)fonts.get(name);
+
+        if (font == null)
+            throw new FontNotAvailableException();
+
+        return font.deriveFont(style, size);
+    }
+
+    private Font urlFont = null;
+    private Map fonts = null;
+
+    private static final Logger logger = Logger.getLogger(FontFactory.class.getName());
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/org/videolan/PortingHelper.java libbluray/src/libbluray/bdj/java-j2se/org/videolan/PortingHelper.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/org/videolan/PortingHelper.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/org/videolan/PortingHelper.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,31 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2013  Petri Hintukainen <phintuka@users.sourceforge.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package org.videolan;
+
+public class PortingHelper {
+
+    public static void stopThread(Thread t) {
+        t.stop();
+    }
+
+    public static void stopThreadGroup(ThreadGroup t) {
+        t.stop();
+    }
+}
diff -Nur libbluray/src/libbluray/bdj/java-j2se.orig/sun/awt/KeyboardFocusManagerPeerProvider.java libbluray/src/libbluray/bdj/java-j2se/sun/awt/KeyboardFocusManagerPeerProvider.java
--- libbluray/src/libbluray/bdj/java-j2se.orig/sun/awt/KeyboardFocusManagerPeerProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ libbluray/src/libbluray/bdj/java-j2se/sun/awt/KeyboardFocusManagerPeerProvider.java	2013-07-26 18:40:43.559129723 +0200
@@ -0,0 +1,27 @@
+/*
+ * This file is part of libbluray
+ * Copyright (C) 2012  libbluray
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+package sun.awt;
+
+import java.awt.KeyboardFocusManager;
+import java.awt.peer.KeyboardFocusManagerPeer;
+
+public abstract interface KeyboardFocusManagerPeerProvider {
+    public abstract KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager kfm);
+}
